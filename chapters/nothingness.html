
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>27. Nothingness &#8212; The Object Oriented Way</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/exercise.css" />
    <link rel="stylesheet" type="text/css" href="../_static/style.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="28. Type hierarchies" href="type-hierarchies.html" />
    <link rel="prev" title="26. Type systems" href="type-systems.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-V69WNXD095"></script>
<script>
                    window.dataLayer = window.dataLayer || [];
                    function gtag(){ dataLayer.push(arguments); }
                    gtag('js', new Date());
                    gtag('config', 'G-V69WNXD095');
                </script>

  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
      
      
      <h1 class="site-logo" id="site-title">The Object Oriented Way</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../index.html">
                    Introduction
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="sets.html">
   1. 🟠 Sets
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="functions.html">
   2. 🟢 Functions
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="algorithms.html">
   3. 🟠 Algorithms
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="computation.html">
   4. 🟠 Computation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="terminals.html">
   5. Terminals
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="syntax.html">
   6. 🟢 Syntax
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="semantics.html">
   7. 🟢 Semantics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="compilation.html">
   8. 🟠 Compilation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="execution.html">
   9. 🟢 Execution
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="interpretation.html">
   10. 🟢 Interpretation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="errors.html">
   11. 🟢 Errors
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="documentation.html">
   12. Documentation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="comments.html">
   13. 🟢 Comments
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="standard-out.html">
   14. Standard out
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="values.html">
   15. 🟢 Values
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="variables.html">
   16. 🟢 Variables
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="standard-in.html">
   17. Standard in
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="selection.html">
   18. Selection
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="indentation.html">
   19. Indentation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="data-types.html">
   20. 🟢 Data types
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="statements.html">
   21. Statements
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="expressions.html">
   22. Expressions
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="operators.html">
   23. Operators
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="type-conversions.html">
   24. Type conversions
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="type-checking.html">
   25. 🟢 Type-checking
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="type-systems.html">
   26. 🟢 Type systems
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   27. 🟠 Nothingness
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="type-hierarchies.html">
   28. Type hierarchies
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="abstraction.html">
   29. Abstraction / Modeling
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="indirection.html">
   30. Indirection
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="paradigms.html">
   31. Paradigms
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="business-logic.html">
   32. Business logic
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="debugging.html">
   33. Debugging
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="arrays.html">
   34. Arrays
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="syntactic-sugar.html">
   35. Syntactic sugar
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="iteration.html">
   36. Iteration
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="command-line-arguments.html">
   37. Command line arguments
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="mutability.html">
   38. Mutability
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="type-testing.html">
   39. Type testing
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="value-and-reference-semantics.html">
   40. Value and reference semantics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="simple-types.html">
   41. Simple types
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="static-methods.html">
   42. Static methods (procedures)
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="purity.html">
   43. Purity
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="static-classes.html">
   44. Static classes (Modules)
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="data-structures.html">
   45. Data structures
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="composition.html">
   46. Composition
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="overloading.html">
   47. Overloading
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="recursion.html">
   48. Recursion
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="scope.html">
   49. Scope
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="namespaces.html">
   50. Namespaces
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="basic-exceptions.html">
   51. Exceptions (part 1)
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="stack-traces.html">
   52. Stack traces
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="pillars.html">
   53. Pillars
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="objects.html">
   54. Objects
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="classes.html">
   55. Classes
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="fields.html">
   56. Fields
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="constructors.html">
   57. Constructors
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="instance-methods.html">
   58. Instance methods
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="type-signatures.html">
   59. Type signatures
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="instance-variables.html">
   60. Instance variables
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="basic-access-modifiers.html">
   61. Access modifiers (basic).
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="properties.html">
   62. Properties
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="object-composition-1.html">
   63. Direct object composition
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="object-composition-2.html">
   64. Indirect object composition
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="immutable-objects.html">
   65. Immutable objects
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="interfaces.html">
   66. Interfaces
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="subtype-polymorphism.html">
   67. Subtype polymorphism
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="inheritance.html">
   68. Inheritance
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="overriding.html">
   69. Overriding
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="hiding.html">
   70. Hiding
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="advanced-access-modifiers.html">
   71. Access modifiers (advanced)
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="object-type-conversions.html">
   72. Type conversions (of objects)
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="advanced-exceptions.html">
   73. Advanced exceptions
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="static.html">
   74. Static
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="prototypes.html">
   75. Prototypes
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="object-composition-3.html">
   76. Abstract indirect object composition
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="base-class-library.html">
   77. Base class library
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="boxing.html">
   78. Boxing
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="structure-types.html">
   79. Structure types
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="anonymous-types.html">
   80. Anonymous types
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="generics.html">
   81. Generics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="variance.html">
   82. Variance
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="business-objects.html">
   83. Business objects
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="requirements.html">
   84. Requirements
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="correctness.html">
   85. Correctness
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="maintainability.html">
   86. Maintainability
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="code-smells.html">
   87. Code smells and anti-patterns
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="coupling.html">
   88. Coupling
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="cohesion.html">
   89. Cohesion
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="refactoring.html">
   90. Refactoring
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="design-principles.html">
   91. Design principles
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="single-responsibility-principle.html">
   92. Single responsibility principle
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="interface-segregation-principle.html">
   93. Interface segregation principle
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="deep-classes.html">
   94. Deep classes
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="types-over-tests.html">
   95. Types over tests
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="define-errors-out-of-existence.html">
   96. Define errors out of existence
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="liskov-substitution-principle.html">
   97. Liskov substitution principle
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="open-closed-principle.html">
   98. Open-closed principle
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="dependency-inversion-principle.html">
   99. Dependency inversion principle
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="composition-over-inheritance.html">
   100. Composition over inheritance
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="documentation-driven-development.html">
   101. Documentation-driven development
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="design-patterns.html">
   102. Design patterns
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="strategy-pattern.html">
   103. Strategy pattern
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="delegates.html">
   104. Delegates
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="extension-methods.html">
   105. Extension methods
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="null-object-pattern.html">
   106. Null object pattern
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="adapter-pattern.html">
   107. Adapter pattern
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="bridge-pattern.html">
   108. Bridge pattern
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="lambdas.html">
   109. Lambdas
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="abstract-factory-pattern.html">
   110. Abstract factory pattern
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="iterator-pattern.html">
   111. Iterator pattern
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="enumerators.html">
   112. Enumerators
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="indexers.html">
   113. Indexers
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="linq.html">
   114. LINQ
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="observer-pattern.html">
   115. Observer pattern
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="events.html">
   116. Events
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="visitor-pattern.html">
   117. Visitor pattern
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="pattern-matching.html">
   118. Pattern matching
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="reading.html">
   119. Suggested reading
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="bibliography.html">
   120. Bibliography
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>
<a href="https://github.com/chrokh/the-oo-way/issues/new?title=Issue%20on%20page%20%2Fchapters/nothingness.html&body=Your%20issue%20content%20here."
   class="headerbtn"
   data-toggle="tooltip"
data-placement="bottom"
title="Open an issue"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>

</a>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="../_sources/chapters/nothingness.md"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.md</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#nullable-value-types">
   27.1. Nullable value types
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#nullable-reference-types">
   27.2. Nullable reference types
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#null-state-static-analysis">
   27.3. Null-state static analysis
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#warnings-as-errors">
   27.4. Warnings as errors
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#null-forgiving-operator">
   27.5. Null-forgiving operator
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#void">
   27.6. Void
  </a>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Nothingness</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#nullable-value-types">
   27.1. Nullable value types
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#nullable-reference-types">
   27.2. Nullable reference types
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#null-state-static-analysis">
   27.3. Null-state static analysis
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#warnings-as-errors">
   27.4. Warnings as errors
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#null-forgiving-operator">
   27.5. Null-forgiving operator
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#void">
   27.6. Void
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section class="tex2jax_ignore mathjax_ignore" id="nothingness">
<h1><span class="section-number">27. </span>Nothingness<a class="headerlink" href="#nothingness" title="Permalink to this headline">#</a></h1>
<p>In imperative programming languages we usually find two kinds of nothingness: <code class="docutils literal notranslate"><span class="pre">null</span></code> and <code class="docutils literal notranslate"><span class="pre">void</span></code>.
The former, <code class="docutils literal notranslate"><span class="pre">null</span></code>, is a value that represents the absence of a value in a variable.
The latter, <code class="docutils literal notranslate"><span class="pre">void</span></code>, is a type that represents the absence of a value returned from an operation.
<code class="docutils literal notranslate"><span class="pre">null</span></code> is an actual value that belongs to many types and that you can hold in a variable.
But <code class="docutils literal notranslate"><span class="pre">void</span></code> is a type of which there are no values.</p>
<p>In this chapter we’re mostly going to talk about <code class="docutils literal notranslate"><span class="pre">null</span></code> and how its treated in C#.
We will briefly discuss <code class="docutils literal notranslate"><span class="pre">void</span></code> but it will be dealt with more appropriately when we get to <a class="reference internal" href="static-methods.html#static-methods"><span class="std std-ref">methods</span></a>.</p>
<section id="nullable-value-types">
<h2><span class="section-number">27.1. </span>Nullable value types<a class="headerlink" href="#nullable-value-types" title="Permalink to this headline">#</a></h2>
<p>In the chapter on <a class="reference internal" href="data-types.html#data-types"><span class="std std-ref">data types</span></a> we modeled the type <code class="docutils literal notranslate"><span class="pre">int</span></code> as a mathematical set.
The set did however not involve the value <code class="docutils literal notranslate"><span class="pre">null</span></code>.
Why?</p>
<p>The type <code class="docutils literal notranslate"><span class="pre">int</span></code> is what is known as a <a class="reference internal" href="value-and-reference-semantics.html#value-and-reference-semantics"><span class="std std-ref">value type</span></a> and value types are, in C#, not “nullable”.
Being “nullable” means that the set that models the type also contains <code class="docutils literal notranslate"><span class="pre">null</span></code>.
If a type is “non-nullable” then the set doesn’t contain <code class="docutils literal notranslate"><span class="pre">null</span></code>.</p>
<p>We can verify that <code class="docutils literal notranslate"><span class="pre">int</span></code> is not nullable by trying to compile a program that assigns the value <code class="docutils literal notranslate"><span class="pre">null</span></code> to an <code class="docutils literal notranslate"><span class="pre">int</span></code>.
If we do, then we get a compiler error.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">null</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-output notranslate"><div class="highlight"><pre><span></span><span class="go">error CS0037: Cannot convert null to &#39;int&#39; because it is a nonnullable value type.</span>
</pre></div>
</div>
<p>The error message above states that the value <code class="docutils literal notranslate"><span class="pre">null</span></code> cannot be converted into an <code class="docutils literal notranslate"><span class="pre">int</span></code> since the type <code class="docutils literal notranslate"><span class="pre">int</span></code> is non-nullable.
This means that <code class="docutils literal notranslate"><span class="pre">null</span></code> isn’t a member of the set <code class="docutils literal notranslate"><span class="pre">int</span></code> and that there is no implicit conversion from <code class="docutils literal notranslate"><span class="pre">null</span></code> to <code class="docutils literal notranslate"><span class="pre">int</span></code>.
Of course there couldn’t possibly exist a general-case conversion from <code class="docutils literal notranslate"><span class="pre">null</span></code> to <code class="docutils literal notranslate"><span class="pre">int</span></code> because which integer could we possibly choose to represent the absence of an integer.
Zero? One? Negative one?
It all depends on context, so it is sensible that C# does not give us a general conversion from <code class="docutils literal notranslate"><span class="pre">null</span></code> to <code class="docutils literal notranslate"><span class="pre">int</span></code>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>As an aside you might be interested to know that some methods, such as <code class="docutils literal notranslate"><span class="pre">String.IndexOf</span></code>, do in fact return values that they assign special meaning to, such as negative one (<code class="docutils literal notranslate"><span class="pre">-1</span></code>), to denote the failure of an operation or the absence of a value to return.
See <a class="reference external" href="https://docs.microsoft.com/en-us/dotnet/api/system.string.indexof?view=net-6.0">the documentation</a> for more information on the IndexOf method for example.</p>
</div>
<p>However, it is possible to create a nullable value type from a non-nullable value type by appending a question mark to the type name.
This means that we are changing the type, not the value.</p>
<p>So if we say <code class="docutils literal notranslate"><span class="pre">int?</span></code> instead of <code class="docutils literal notranslate"><span class="pre">int</span></code> then we are dealing with a nullable value type.
Appending a question mark works to create a nullable type works for all value types.</p>
<p>So the set <span class="math notranslate nohighlight">\(\mathit{int?}\)</span> is the union of the set <span class="math notranslate nohighlight">\(\mathit{int}\)</span> and the <code class="docutils literal notranslate"><span class="pre">null</span></code> type which is a singleton set whose only element is <span class="math notranslate nohighlight">\(\mathit{null}\)</span>.</p>
<div class="math notranslate nohighlight">
\[
\mathit{int?} = \mathit{int} \cup \{ \mathit{null} \}
\]</div>
<p>The set <span class="math notranslate nohighlight">\(\mathit{int?}\)</span> corresponds to the data type <code class="docutils literal notranslate"><span class="pre">int?</span></code> and we can now actually compile a program that assigns <code class="docutils literal notranslate"><span class="pre">null</span></code> to a variable of this type.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">int?</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">null</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-output notranslate"><div class="highlight"><pre><span></span><span class="go">Build succeeded.</span>
</pre></div>
</div>
<p>Whether this is a sensible idea or not is a different question.
In the chapter on <a class="reference internal" href="values.html"><span class="doc std std-doc">Values</span></a> we already alluded to some of the difficulties arising from the usage of <code class="docutils literal notranslate"><span class="pre">null</span></code>.
For now though, it is useful to keep exploring the concept of <code class="docutils literal notranslate"><span class="pre">null</span></code> as we are learning about how data types work.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Being non-nullable is not the only property of value types.
Unless implemented otherwise, value types also have, what’s known as, “value semantics” rather than “reference semantics”.
But more on this in the chapter on <a class="reference internal" href="value-and-reference-semantics.html#value-and-reference-semantics"><span class="std std-ref">value and reference semantics</span></a>.</p>
</div>
<p>Broadly speaking, there are two categories of types in C#: value types and reference types.
We’ll talk more about what these base types are in the chapter on <a class="reference internal" href="value-and-reference-semantics.html#value-and-reference-semantics"><span class="std std-ref">value and reference type semantics</span></a>.
For now, we should however mention that prior to <a class="reference external" href="https://docs.microsoft.com/en-us/dotnet/csharp/nullable-references">C# 8.0</a>, all reference types were nullable.</p>
<p>We should also mention that when you do object oriented programming, our main building block is the object.
And since objects are reference types, this used to mean that most of our custom types were nullable.
If null is a billion dollar mistake, reference types are nullable, we use mostly reference types, and objects are reference types, then most of our code is subject to this billoion dollar mistake.
Not ideal.</p>
</section>
<section id="nullable-reference-types">
<h2><span class="section-number">27.2. </span>Nullable reference types<a class="headerlink" href="#nullable-reference-types" title="Permalink to this headline">#</a></h2>
<p>Fortunately, C# now has a setting called “nullable reference types” which is enabled by default in new projects since <a class="reference external" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/nullable-reference-types">.NET 6 (C# 10)</a>.
You can find the setting in your <code class="docutils literal notranslate"><span class="pre">.csproj</span></code> file and it looks like this:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;Nullable&gt;</span>enable<span class="nt">&lt;/Nullable&gt;</span>
</pre></div>
</div>
<p>The short story is that, with this setting turned on, reference types are no longer nullable.
However, if you try to assign the literal <code class="docutils literal notranslate"><span class="pre">null</span></code> to a variable that’s of a reference type you don’t actually get a type error but simply a compiler warning.
This warning is emitted from a static code analysis procedure known as null state analysis.</p>
<p>Take the reference type <code class="docutils literal notranslate"><span class="pre">string</span></code> for example.
Let’s say we declare a variable of type <code class="docutils literal notranslate"><span class="pre">string</span></code> and initialize it to the value <code class="docutils literal notranslate"><span class="pre">null</span></code>.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">string</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">null</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>If we have the setting for nullable reference types turned on, then we get the following warning upon compilation:</p>
<div class="highlight-output notranslate"><div class="highlight"><pre><span></span><span class="go">warning CS8600: Converting null literal or possible null value to non-nullable type.</span>
</pre></div>
</div>
<p>Notice how the error message is referring to the variable of type <code class="docutils literal notranslate"><span class="pre">string</span></code> as being non-nullable.
The error message is structured exactly like a type error.
If, for example, we tried to assign a value of type <code class="docutils literal notranslate"><span class="pre">int</span></code> to a variable of type <code class="docutils literal notranslate"><span class="pre">string</span></code> we would get an error message with the same structure:</p>
<div class="highlight-output notranslate"><div class="highlight"><pre><span></span><span class="go">error CS0029: Cannot implicitly convert type &#39;int&#39; to &#39;string&#39;.</span>
</pre></div>
</div>
<p>Yet, in the case where we assign a null literal to a value of the non-nullable reference type string this is not a type error in the classic sense.
For one, it’s a warning and not an error.
But also, this is a warning that’s emitted upon null state analysis and not by type checking.
As we shall see soon, null state analysis is a much more complicated procedure than type-checking.
In <a class="reference internal" href="type-checking.html"><span class="doc std std-doc">type-checking</span></a> we simply check whether the type of a value is the same as, or is <a class="reference internal" href="type-conversions.html"><span class="doc std std-doc">implicitly convertible</span></a> to, a value of the expected type.
If <code class="docutils literal notranslate"><span class="pre">null</span></code> is a legal value of the expected type, or if it is possible to implicitly convertible to a value of the expected type then the program simply type-checks.
In null state analysis however, we look at the actual flow of the program in attempts to verify whether a value might ever contain the value <code class="docutils literal notranslate"><span class="pre">null</span></code>.
If the compiler cannot guarantee that <code class="docutils literal notranslate"><span class="pre">null</span></code> is not ever used where a certain reference type is expected it will emit a warning upon compilation.</p>
<p>So it isn’t entirely honest to call <code class="docutils literal notranslate"><span class="pre">string</span></code> non-nullable since we are still able to compile and run programs that uses <code class="docutils literal notranslate"><span class="pre">null</span></code> where values of type <code class="docutils literal notranslate"><span class="pre">string</span></code> are expected.
It’s not that <code class="docutils literal notranslate"><span class="pre">null</span></code> isn’t a valid member of the set underlying each reference type or that there no longer exists an implicit conversion from <code class="docutils literal notranslate"><span class="pre">null</span></code> to the type in question.
It’s that whenever you try to assign <code class="docutils literal notranslate"><span class="pre">null</span></code> to a non-nullable reference type you simply get a compiler warning.
You can still compile the program and it might run just fine.</p>
<p>So, while both value types and reference types are non-nullable the way they are so differs in two important ways:</p>
<ol class="simple">
<li><p>Value types are non-nullable regardless of whether we turn on the <code class="docutils literal notranslate"><span class="pre">Nullable</span></code> setting or not. The <code class="docutils literal notranslate"><span class="pre">Nullable</span></code> setting only affects the nullability of reference types.</p></li>
<li><p>A program that assigns <code class="docutils literal notranslate"><span class="pre">null</span></code> to a value type can <em>not</em> be compiled while a program that assigns <code class="docutils literal notranslate"><span class="pre">null</span></code> to a reference type <em>can</em> be. In the case of value types you get a compilation error but in the case of reference types you only get a warning.</p></li>
<li><p>Assigning <code class="docutils literal notranslate"><span class="pre">null</span></code> to a value type causes an error at type-checking while assigning <code class="docutils literal notranslate"><span class="pre">null</span></code> to a non-nullable reference type causes a warning during null-state analysis if that code can be reached.</p></li>
</ol>
<p>The third point can be driven home by asking yourself why one of the examples below is a compileable program while the other is not.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">string</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">;</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">false</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">s</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">null</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-output notranslate"><div class="highlight"><pre><span></span><span class="go">warning CS0162: Unreachable code detected</span>

<span class="go">Build succeeded.</span>
</pre></div>
</div>
<p>In the case above, we generate unreachable code (line 3).
Since the statement that assigns <code class="docutils literal notranslate"><span class="pre">null</span></code> to our non-nullable variable isn’t ever executed this is compileable (but pointless).</p>
<p>Compare this to the case below where we try to assign <code class="docutils literal notranslate"><span class="pre">null</span></code> to a value type but wrap it in a conditional that’s always false which means that it will never happen.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">string</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">;</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">false</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">s</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-output notranslate"><div class="highlight"><pre><span></span><span class="go">error CS0029: Cannot implicitly convert type &#39;int&#39; to &#39;string&#39;</span>
</pre></div>
</div>
<p>In this case we get a type-error even if the code cannot ever be reached.
This is because the error is emitted by type-checking rather than null-state static analysis.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>In the <a class="reference external" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-messages/nullable-warnings">C# manual</a> you can find a summary of all the warnings you can get as a consequence of enabling nullable reference types.</p>
</div>
<p>Remember how we said that you can use the question mark symbol (<code class="docutils literal notranslate"><span class="pre">?</span></code>) to turn a value type, which is non-nullable by default, into a nullable value type?
With the setting <code class="docutils literal notranslate"><span class="pre">Nullable</span></code> enabled reference types are, as we have seen, now also non-nullable.
We can however, just like with value types, turn any non-nullable reference type into a nullable reference type by appending a question mark to the type name.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">string?</span><span class="w"> </span><span class="n">nullableString</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">null</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-output notranslate"><div class="highlight"><pre><span></span><span class="go">Build succeeded.</span>
</pre></div>
</div>
<div class="exercise admonition" id="chapters/nothingness-exercise-0">

<p class="admonition-title"><span class="caption-number">Exercise 27.1 </span></p>
<section id="exercise-content">
<p>What do the terms “nullable” and “non-nullable” mean in the context of types?</p>
</section>
</div>
<div class="exercise admonition" id="chapters/nothingness-exercise-1">

<p class="admonition-title"><span class="caption-number">Exercise 27.2 </span></p>
<section id="exercise-content">
<p>With the nullable reference types setting turned on in C#, both reference types and value types are non-nullable. However, they are non-nullable in slightly different ways, how? Give an example.</p>
<p>Hint: Think about the difference between null-state analysis and type-checking.</p>
</section>
</div>
</section>
<section id="null-state-static-analysis">
<h2><span class="section-number">27.3. </span>Null-state static analysis<a class="headerlink" href="#null-state-static-analysis" title="Permalink to this headline">#</a></h2>
<p>The null-state static analysis of the C# compiler is actually quite sophisticated.
According to <a class="reference external" href="https://docs.microsoft.com/en-us/dotnet/csharp/nullable-references">the documentation</a>, the compiler can tag a variable as <code class="docutils literal notranslate"><span class="pre">not-null</span></code> in two ways:</p>
<ol class="simple">
<li><p>If a variable has been assigned a value that is known to not be <code class="docutils literal notranslate"><span class="pre">null</span></code>.</p></li>
<li><p>If a variable has already been checked against <code class="docutils literal notranslate"><span class="pre">null</span></code> and has not been modified since.</p></li>
</ol>
<p>In all other cases, the variable is tagged as <code class="docutils literal notranslate"><span class="pre">maybe-null</span></code>.
Or in other words, in all other cases, the compiler cannot guarantee that the variable doesn’t contain the value <code class="docutils literal notranslate"><span class="pre">null</span></code>.</p>
<p>If we want to convert a value contained in a variable which has been tagged as <code class="docutils literal notranslate"><span class="pre">maybe-null</span></code> to a non-nullable type then we must first check whether the value actually is <code class="docutils literal notranslate"><span class="pre">null</span></code>.
Only if we can show that the value isn’t in fact <code class="docutils literal notranslate"><span class="pre">null</span></code> are we allowed to convert the value into a type which is non-nullable.
If we don’t check first then the compiler will complain and we’ll get a warning.</p>
<p>Take, for example, the concept of reading input from the user using the method <code class="docutils literal notranslate"><span class="pre">Console.ReadLine</span></code>.
If we read the <a class="reference external" href="https://docs.microsoft.com/en-us/dotnet/api/system.console.readline?view=net-6.0">documentation</a> for the method then we can see that it doesn’t return a <code class="docutils literal notranslate"><span class="pre">string</span></code> but a <code class="docutils literal notranslate"><span class="pre">string?</span></code>.
Meaning it doesn’t return a non-nullable string but a nullable string.</p>
<p>In the documentation we can see that we get <code class="docutils literal notranslate"><span class="pre">null</span></code> when there are no more lines available to read from standard input.
When we are running our program interactively and the user types in a response to our <code class="docutils literal notranslate"><span class="pre">Console.ReadLine</span></code> call then we never actually see <code class="docutils literal notranslate"><span class="pre">null</span></code>.
However, since it can occurr if we run the program non-interactively the compiler cannot guarantee that the result of <code class="docutils literal notranslate"><span class="pre">Console.ReadLine</span></code> is not <code class="docutils literal notranslate"><span class="pre">null</span></code> in our program and hence cannot tag the result as <code class="docutils literal notranslate"><span class="pre">not-null</span></code>.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">string?</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">Console</span><span class="p">.</span><span class="n">ReadLine</span><span class="p">();</span><span class="w"></span>
<span class="kt">string</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>The variable <code class="docutils literal notranslate"><span class="pre">x</span></code> in the example above is therefore tagged as <code class="docutils literal notranslate"><span class="pre">maybe-null</span></code>.
Since we have a value that’s possibly <code class="docutils literal notranslate"><span class="pre">null</span></code> we “cannot” store it in a non-nullable variable and consequently get a warning if we try to:</p>
<div class="highlight-output notranslate"><div class="highlight"><pre><span></span><span class="go">warning CS8600: Converting null literal or possible null value to non-nullable type.</span>
</pre></div>
</div>
<p>Note that I put “cannot” within air quotes above since it is, as we’ve already discussed, slightly dishonest to say that non-nullable reference types cannot store the value <code class="docutils literal notranslate"><span class="pre">null</span></code> since they actually can.
We merely get a compiler warning.
In the next section we will however see how we can turn these warnings into errors which means that we no longer need the air quotes.</p>
<p>Ok, but is it possible to convert a nullable reference type to a non-nullable reference type if the value is tagged as <code class="docutils literal notranslate"><span class="pre">not-null</span></code>?
Yes, it is.
In the example below, we assign the variable <code class="docutils literal notranslate"><span class="pre">x</span></code> a literal string and not <code class="docutils literal notranslate"><span class="pre">null</span></code>.
This causes <code class="docutils literal notranslate"><span class="pre">x</span></code> to be tagged as <code class="docutils literal notranslate"><span class="pre">not-null</span></code> which means that we can safely and implicitly convert our <code class="docutils literal notranslate"><span class="pre">string?</span></code> which is nullable to a <code class="docutils literal notranslate"><span class="pre">string</span></code> which is non-nullable.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">string?</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;Hello&quot;</span><span class="p">;</span><span class="w"></span>
<span class="kt">string</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-output notranslate"><div class="highlight"><pre><span></span><span class="go">Build succeeded.</span>
</pre></div>
</div>
<p>So what do we do in the case of our <code class="docutils literal notranslate"><span class="pre">ReadLine</span></code> example?
Of course we would like the highest grade of safety in our programs.
To avoid run-time errors we would of course like to use the non-nullable type <code class="docutils literal notranslate"><span class="pre">string</span></code> rather than the nullable type <code class="docutils literal notranslate"><span class="pre">string?</span></code>.
Are we doomed to having to resort to nullable types as soon as we have the possibility of <code class="docutils literal notranslate"><span class="pre">null</span></code>?
No, not at all.</p>
<p>Remember how we said that the compiler’s static null-state analysis can tag a variable as <code class="docutils literal notranslate"><span class="pre">not-null</span></code> if we’ve “checked it against <code class="docutils literal notranslate"><span class="pre">null</span></code>”?
What does this mean?
It simply means that we take our variable, stick it in a conditional, and check if the value of our variable is <code class="docutils literal notranslate"><span class="pre">null</span></code>.
In the branch where the variable is determined to not be <code class="docutils literal notranslate"><span class="pre">null</span></code> the variable is tagged as <code class="docutils literal notranslate"><span class="pre">not-null</span></code>.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">string?</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">Console</span><span class="p">.</span><span class="n">ReadLine</span><span class="p">();</span><span class="w"></span>
<span class="kt">string</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="p">!=</span><span class="w"> </span><span class="k">null</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">y</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="c1">// Here x is tagged as not-null.</span>
</pre></div>
</div>
<div class="highlight-output notranslate"><div class="highlight"><pre><span></span><span class="go">Build succeeded.</span>
</pre></div>
</div>
<p>Of course, we’re left with the question of what to do in the else-branch of the if-statement in the example above.
But, then again, this is precisely the power of static type-checking and static null-state analysis.
This is precisly what we’re looking for when trying to eliminate the billion dollar mistake called <code class="docutils literal notranslate"><span class="pre">null</span></code>.
We’ve not actually introduced more paths to our program.
We’ve merely made paths that we’re previously implicit and possibly lead to run-time errors, explicit so that we can ensure that they don’t lead to run-time errors.</p>
<p>Hopefully you can however see the bigger picture.
If you have something that <em>might be</em> <code class="docutils literal notranslate"><span class="pre">null</span></code> then you cannot convert it into something that’s <em>certainly not</em> <code class="docutils literal notranslate"><span class="pre">null</span></code> without first checking whether you actually have <code class="docutils literal notranslate"><span class="pre">null</span></code>.
If not, then I strongly advise you to return this this section after having read those chapters.</p>
<div class="exercise admonition" id="chapters/nothingness-exercise-2">

<p class="admonition-title"><span class="caption-number">Exercise 27.3 </span></p>
<section id="exercise-content">
<p>What is null-state static analysis in C#?</p>
</section>
</div>
<div class="exercise admonition" id="chapters/nothingness-exercise-3">

<p class="admonition-title"><span class="caption-number">Exercise 27.4 </span></p>
<section id="exercise-content">
<p>What do we mean when we say that the C# compiler tags variables as <code class="docutils literal notranslate"><span class="pre">not-null</span></code> or <code class="docutils literal notranslate"><span class="pre">maybe-null</span></code>?</p>
</section>
</div>
</section>
<section id="warnings-as-errors">
<h2><span class="section-number">27.4. </span>Warnings as errors<a class="headerlink" href="#warnings-as-errors" title="Permalink to this headline">#</a></h2>
<p>Due to the immense risk of suffering run-time errors at the hand of <code class="docutils literal notranslate"><span class="pre">null</span></code> references I <em>strongly recommend</em> that you configure your project so that the compiler emits <em>errors</em> instead of <em>warnings</em>.
This means that it is impossible to compile your program and subsequently impossible to run it.</p>
<p>Configuring your project to treat <code class="docutils literal notranslate"><span class="pre">Nullable</span></code> warnings as errors is simple.
Open your <code class="docutils literal notranslate"><span class="pre">.csproj</span></code> file, and locate the line that enables the <code class="docutils literal notranslate"><span class="pre">Nullable</span></code> setting and add another line that sets the property <code class="docutils literal notranslate"><span class="pre">WarningsAsErrors</span></code> to the property <code class="docutils literal notranslate"><span class="pre">Nullable</span></code>.
The two lines should look like this:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;WarningsAsErrors&gt;</span>Nullable<span class="nt">&lt;/WarningsAsErrors&gt;</span>
<span class="nt">&lt;Nullable&gt;</span>enable<span class="nt">&lt;/Nullable&gt;</span>
</pre></div>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>I <strong>strongly recommend</strong> that you configure your projects so that the compiler emits <em>errors</em> instead of <em>warnings</em> upon possible null references.</p>
</div>
<p>I can only assume that the C# language designers chose to emit warnings instead of errors since many developers would be faced with a sea of errors if they kept programming as usual.
In my mind however, this sea of errors is a very good thing.
It only goes to show how very <em>risky</em> our code is.</p>
<p>We should not be concerned about the large number of errors that we have to get rid of to make our code compile, we should be concerned about why we write such code in the first place.
Remember the quote by <span id="id1">Martin [<a class="reference internal" href="bibliography.html#id5" title="R. C. Martin. Clean Agile: Back to Basics. Robert C. Martin Series. Pearson Education, Limited, 2019. ISBN 9780135781869. URL: http://amazon.christopherokhravi.com?id=0135781868.">2019</a>]</span> we discussed in the chapter on <a class="reference internal" href="comments.html#comments"><span class="std std-ref">comments</span></a>?
“The only way to go fast, is to go well.”
If you don’t buy this argument, you might as well not bother with static typing at all.</p>
<div class="admonition danger">
<p class="admonition-title">Danger</p>
<p>All following code examples in this book will assumed that you are treating null reference warnings as errors.</p>
</div>
<p>When we’ve turned on the setting for treating nullable warnings as errors it is suddenly slightly more truthful to claim that <code class="docutils literal notranslate"><span class="pre">null</span></code> is not a member of any non-nullable reference type.
It still holds however that errors are emitted in a slightly different fashion since they follow as a consequence of null state analysis rather than type-checking.
So even if we treat nullable warnings as errors we are still able to compile code that assigns <code class="docutils literal notranslate"><span class="pre">null</span></code> to a non-nullable reference type if the compiler can prove that said code is never executed.</p>
</section>
<section id="null-forgiving-operator">
<h2><span class="section-number">27.5. </span>Null-forgiving operator<a class="headerlink" href="#null-forgiving-operator" title="Permalink to this headline">#</a></h2>
<p>Finally we must talk about the null-forgiving operator.
The null-state static analyzer isn’t perfect which means sometimes it tags a value as <code class="docutils literal notranslate"><span class="pre">maybe-null</span></code> even though it actually never is <code class="docutils literal notranslate"><span class="pre">null</span></code>.</p>
<p>In the silly example below we are declaring a nullable integer (<code class="docutils literal notranslate"><span class="pre">int?</span></code>) and initialize it to the non-null value <code class="docutils literal notranslate"><span class="pre">1</span></code>.
We then use a condition to say that if the value is <code class="docutils literal notranslate"><span class="pre">2</span></code>, which of course it is not, then and only then will we change the value to <code class="docutils literal notranslate"><span class="pre">null</span></code>.
The value will of course never be changed to <code class="docutils literal notranslate"><span class="pre">null</span></code> since the variable is always initialized to <code class="docutils literal notranslate"><span class="pre">1</span></code>.
If we try to compile the code however we still get an error (assuming that we are treating null reference warnings as errors).</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">int?</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="p">==</span><span class="w"> </span><span class="m">2</span><span class="p">)</span><span class="w">  </span><span class="c1">// This condition is false.</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">null</span><span class="p">;</span><span class="w">  </span><span class="c1">// So this line will never run.</span>

<span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-output notranslate"><div class="highlight"><pre><span></span><span class="go">error CS8629: Nullable value type may be null.</span>
</pre></div>
</div>
<p>Apologies again for using conditionals before we’ve talked about <a class="reference internal" href="selection.html"><span class="doc std std-doc">selection</span></a>.
Hopefully you see the general idea.
We’re using enough <a class="reference internal" href="indirection.html#indirection"><span class="std std-ref">indirection</span></a> for the compiler to be unable to determine that the value won’t ever be <code class="docutils literal notranslate"><span class="pre">null</span></code>.</p>
<p>The conflicting part in our example is the last one where we try to convert a nullable integer to a regular integer.
To solve this issue we could use the null-forgiving operator which is a bang (<code class="docutils literal notranslate"><span class="pre">!</span></code>).
By appending the null-forgiving operator to our variable name we tell the compiler that even if it is has tagged the value as <code class="docutils literal notranslate"><span class="pre">maybe-null</span></code> we know for a fact that it cannot be <code class="docutils literal notranslate"><span class="pre">null</span></code> and that the value hence should be retagged as <code class="docutils literal notranslate"><span class="pre">not-null</span></code>.
Notice the bang in the rewriting of the last line below.
This makes the program compile and run just fine.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">x</span><span class="p">!;</span><span class="w"></span>
</pre></div>
</div>
<p>It should be noted that the program in our example is pointless in multiple ways and that it of course never should be encountered in any real world setting.
A more realistic example would be if you want to depend on some code that you cannot rewrite and that this code returns something nullable but you know that you use the code in a way such that you <em>never</em> encounter <code class="docutils literal notranslate"><span class="pre">null</span></code>.
This makes sense, but is risky.
If you’re going to do this I highly recommend creating a wrapper to centralize and encapsulate this logic.
See for example the chapter on <a class="reference internal" href="adapter-pattern.html"><span class="doc std std-doc">adapter pattern</span></a>.</p>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>The null-forgiving operator should be <em>used with extreme caution</em>.
There are very few scenarios that actually <em>require</em> it and in all other cases you can rewrite the code that you depend on to avoid introducing possible <code class="docutils literal notranslate"><span class="pre">null</span></code> states in the first place.
Treat the cause of the problem, not the symptoms.
The null-forgiving operator is a way to treat the symptoms.</p>
<p>All scenarios that require the null-forgiving operator involve code or states that you don’t control, so think long and hard if it isn’t possible to rewrite your code to avoid the problem in the first place.
Avoiding the introduction of <code class="docutils literal notranslate"><span class="pre">null</span></code> in the first place is a much better solution.</p>
<p>As soon as you introduce the null-forgiving operator you are back at the mercy of null-state run-time errors.</p>
</div>
<div class="exercise admonition" id="chapters/nothingness-exercise-4">

<p class="admonition-title"><span class="caption-number">Exercise 27.5 </span></p>
<section id="exercise-content">
<p>How can we convert a value tagged as <code class="docutils literal notranslate"><span class="pre">maybe-null</span></code> to a value tagged as <code class="docutils literal notranslate"><span class="pre">not-null</span></code>?</p>
</section>
</div>
</section>
<section id="void">
<h2><span class="section-number">27.6. </span>Void<a class="headerlink" href="#void" title="Permalink to this headline">#</a></h2>
<p>In terms of set theory, you can think of the type <code class="docutils literal notranslate"><span class="pre">void</span></code> as the empty set.
In theory, there are no elements of type <code class="docutils literal notranslate"><span class="pre">void</span></code>.
Compare this to the type <code class="docutils literal notranslate"><span class="pre">null</span></code> which is a singleton set, that only contains the value with the same name, namely <code class="docutils literal notranslate"><span class="pre">null</span></code>.
Consequently you couldn’t possible store a reference to something of type <code class="docutils literal notranslate"><span class="pre">void</span></code> in a variable.</p>
<p>We have not yet talked about <span class="xref myst">methods</span>, so the type <code class="docutils literal notranslate"><span class="pre">void</span></code> will not make much sense before we get there.
For now I therefore simply want to mention that methods have, what’s known as, return types and if a method doesn’t return a value then we say that it’s return type is <code class="docutils literal notranslate"><span class="pre">void</span></code>.
It’s quite intutive really.
If a method doesn’t return a value, but all methods must state what the type is of the things that it returns then it makes sense to say that the method returns things of type <code class="docutils literal notranslate"><span class="pre">void</span></code>.
Since there are no values of type <code class="docutils literal notranslate"><span class="pre">void</span></code> the method cannot ever return a value.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>This is way beyond the scope of this book, but due to the fact that you can declare pointers of type <code class="docutils literal notranslate"><span class="pre">void</span></code> the case could be made that <code class="docutils literal notranslate"><span class="pre">void</span></code> is a singleton set.
If you’re keen to learn more about this, see the page on <a class="reference external" href="https://docs.microsoft.com/en-ca/dotnet/csharp/language-reference/unsafe-code#pointer-types">Pointer types</a> in the documentation.</p>
</div>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./chapters"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="type-systems.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title"><span class="section-number">26. </span>Type systems</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="type-hierarchies.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">28. </span>Type hierarchies</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Christopher Okhravi<br/>
  
      &copy; Copyright 2022.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>