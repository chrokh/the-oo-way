<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />
<link rel="index" title="Index" href="../genindex.html" /><link rel="search" title="Search" href="../search.html" />

    <!-- Generated with Sphinx 5.0.2 and Furo 2023.03.27 -->
        <title>Type systems - The Object Oriented Way</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?digest=fad236701ea90a88636c2a8c73b44ae642ed2a53" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/exercise.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    <link rel="stylesheet" type="text/css" href="../_static/style.css" />
    
    


<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">The Object Oriented Way</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand centered" href="../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo" src="../_static/logo.png" alt="Logo"/>
  </div>
  
  <span class="sidebar-brand-text">The Object Oriented Way</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul>
<li class="toctree-l1"><a class="reference internal" href="syntax.html">1. Syntax</a></li>
<li class="toctree-l1"><a class="reference internal" href="hello-world.html">2. Hello world</a></li>
<li class="toctree-l1"><a class="reference internal" href="compilation.html">3. Compilation</a></li>
<li class="toctree-l1"><a class="reference internal" href="execution.html">4. Execution</a></li>
<li class="toctree-l1"><a class="reference internal" href="interpretation.html">5. Interpretation</a></li>
<li class="toctree-l1"><a class="reference internal" href="comments.html">6. Comments</a></li>
<li class="toctree-l1"><a class="reference internal" href="values.html">7. Values</a></li>
<li class="toctree-l1"><a class="reference internal" href="variables.html">8. Variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="data-types.html">9. Data types</a></li>
<li class="toctree-l1"><a class="reference internal" href="expressions.html">10. Expressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="arithmetic-operators.html">11. Arithmetic operators</a></li>
<li class="toctree-l1"><a class="reference internal" href="equality-operators.html">12. Equality operators</a></li>
<li class="toctree-l1"><a class="reference internal" href="relational-operators.html">13. Relational operators</a></li>
<li class="toctree-l1"><a class="reference internal" href="logical-operators.html">14. Logical operators</a></li>
<li class="toctree-l1"><a class="reference internal" href="assignment-operator.html">15. Assignment operator</a></li>
<li class="toctree-l1"><a class="reference internal" href="precedence.html">16. Precedence</a></li>
<li class="toctree-l1"><a class="reference internal" href="associativity.html">17. Associativity</a></li>
<li class="toctree-l1"><a class="reference internal" href="constants.html">18. Constants</a></li>
<li class="toctree-l1"><a class="reference internal" href="statements.html">19. Statements</a></li>
<li class="toctree-l1"><a class="reference internal" href="type-inference.html">20. Type inference</a></li>
<li class="toctree-l1"><a class="reference internal" href="type-checking.html">21. Type checking</a></li>
<li class="toctree-l1"><a class="reference internal" href="floating-point-types.html">22. Floating-point types</a></li>
<li class="toctree-l1"><a class="reference internal" href="enumeration-types.html">23. Enumeration types</a></li>
<li class="toctree-l1"><a class="reference internal" href="selection-statements.html">24. Selection statements</a></li>
<li class="toctree-l1"><a class="reference internal" href="selection-expressions.html">25. Selection expressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="iteration.html">26. Iteration</a></li>
<li class="toctree-l1"><a class="reference internal" href="arrays.html">27. Arrays</a></li>
<li class="toctree-l1"><a class="reference internal" href="reference-types.html">28. Reference types</a></li>
<li class="toctree-l1"><a class="reference internal" href="value-types.html">29. Value types</a></li>
<li class="toctree-l1"><a class="reference internal" href="local-functions.html">30. Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="fat-arrows.html">31. Fat arrows</a></li>
<li class="toctree-l1"><a class="reference internal" href="recursion.html">32. Recursion</a></li>
<li class="toctree-l1"><a class="reference internal" href="objects.html">33. Objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="classes.html">34. Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="access-modifiers.html">35. Access modifiers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fields.html">36. Fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="constructors.html">37. Constructors</a></li>
<li class="toctree-l1"><a class="reference internal" href="the-this-keyword.html">38. The <code class="docutils literal notranslate"><span class="pre">this</span></code> keyword</a></li>
<li class="toctree-l1"><a class="reference internal" href="instance-methods.html">39. Instance methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="encapsulation.html">40. Encapsulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="auto-implemented-properties.html">41. Auto-implemented properties</a></li>
<li class="toctree-l1"><a class="reference internal" href="manually-implemented-properties.html">42. Manually implemented properties</a></li>
<li class="toctree-l1"><a class="reference internal" href="object-initializers.html">43. Object initializers</a></li>
<li class="toctree-l1"><a class="reference internal" href="read-only-fields.html">44. Read-only fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="read-only-properties.html">45. Read-only properties</a></li>
<li class="toctree-l1"><a class="reference internal" href="computed-properties.html">46. Computed properties</a></li>
<li class="toctree-l1"><a class="reference internal" href="required-properties-and-fields.html">47. Required properties and fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="init-only-properties.html">48. Init-only properties</a></li>
<li class="toctree-l1"><a class="reference internal" href="instance-method-overloading.html">49. Instance method overloading</a></li>
<li class="toctree-l1"><a class="reference internal" href="constructor-overloading.html">50. Constructor overloading</a></li>
<li class="toctree-l1"><a class="reference internal" href="static-fields.html">51. Static fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="static-constructors.html">52. Static constructors</a></li>
<li class="toctree-l1"><a class="reference internal" href="static-methods.html">53. Static methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="static-classes.html">54. Static classes (Modules)</a></li>
<li class="toctree-l1"><a class="reference internal" href="extension-methods.html">55. Extension methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="object-composition.html">56. Object composition</a></li>
<li class="toctree-l1"><a class="reference internal" href="concrete-constructed-object-composition.html">57. Concrete constructed object composition</a></li>
<li class="toctree-l1"><a class="reference internal" href="concrete-injected-object-composition.html">58. Concrete injected object composition</a></li>
<li class="toctree-l1"><a class="reference internal" href="interfaces.html">59. Interfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="subtype-polymorphism.html">60. Subtype polymorphism</a></li>
<li class="toctree-l1"><a class="reference internal" href="inheritance.html">61. Inheritance</a></li>
<li class="toctree-l1"><a class="reference internal" href="advanced-access-modifiers.html">62. Advanced access modifiers</a></li>
<li class="toctree-l1"><a class="reference internal" href="abstract-classes.html">63. Abstract classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="object-type-conversions.html">64. Type conversions (of objects)</a></li>
<li class="toctree-l1"><a class="reference internal" href="abstract-constructed-object-composition.html">65. Abstract constructed object composition</a></li>
<li class="toctree-l1"><a class="reference internal" href="abstract-injected-object-composition.html">66. Abstract injected object composition</a></li>
<li class="toctree-l1"><a class="reference internal" href="variance.html">67. Variance</a></li>
<li class="toctree-l1"><a class="reference internal" href="liskov-substitution-principle.html">68. Liskov substitution principle</a></li>
<li class="toctree-l1"><a class="reference internal" href="generics.html">69. Generics</a></li>
<li class="toctree-l1"><a class="reference internal" href="generic-type-parameters.html">70. Generic type parameters</a></li>
<li class="toctree-l1"><a class="reference internal" href="generic-types.html">71. Generic types</a></li>
<li class="toctree-l1"><a class="reference internal" href="generic-methods.html">72. Generic methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="type-parameter-constraints.html">73. Type parameter constraints</a></li>
<li class="toctree-l1"><a class="reference internal" href="variant-generic-interfaces.html">74. Variant generic interfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="design-principles.html">75. Design principles</a></li>
<li class="toctree-l1"><a class="reference internal" href="types-over-tests.html">76. Types over tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="single-responsibility-principle.html">77. Single responsibility principle</a></li>
<li class="toctree-l1"><a class="reference internal" href="interface-segregation-principle.html">78. Interface segregation principle</a></li>
<li class="toctree-l1"><a class="reference internal" href="deep-classes.html">79. Deep classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="define-errors-out-of-existence.html">80. Define errors out of existence</a></li>
<li class="toctree-l1"><a class="reference internal" href="open-closed-principle.html">81. Open-closed principle</a></li>
<li class="toctree-l1"><a class="reference internal" href="dependency-inversion-principle.html">82. Dependency inversion principle</a></li>
<li class="toctree-l1"><a class="reference internal" href="composition-over-inheritance.html">83. Composition over inheritance</a></li>
<li class="toctree-l1"><a class="reference internal" href="design-patterns.html">84. Design patterns</a></li>
<li class="toctree-l1"><a class="reference internal" href="strategy-pattern.html">85. Strategy pattern</a></li>
<li class="toctree-l1"><a class="reference internal" href="null-object-pattern.html">86. Null object pattern</a></li>
<li class="toctree-l1"><a class="reference internal" href="bridge-pattern.html">87. Bridge pattern</a></li>
<li class="toctree-l1"><a class="reference internal" href="delegates.html">88. Delegates</a></li>
<li class="toctree-l1"><a class="reference internal" href="observer-pattern.html">89. Observer pattern</a></li>
<li class="toctree-l1"><a class="reference internal" href="events.html">90. Events</a></li>
<li class="toctree-l1"><a class="reference internal" href="adapter-pattern.html">91. Adapter pattern</a></li>
<li class="toctree-l1"><a class="reference internal" href="factory-method-pattern.html">92. Factory method pattern</a></li>
<li class="toctree-l1"><a class="reference internal" href="composite-pattern.html">93. Composite pattern</a></li>
<li class="toctree-l1"><a class="reference internal" href="state-pattern.html">94. State pattern</a></li>
<li class="toctree-l1"><a class="reference internal" href="iterator-pattern.html">95. Iterator pattern</a></li>
<li class="toctree-l1"><a class="reference internal" href="visitor-pattern.html">96. Visitor pattern</a></li>
<li class="toctree-l1"><a class="reference internal" href="pattern-matching.html">97. Pattern matching</a></li>
<li class="toctree-l1"><a class="reference internal" href="lambdas.html">98. Lambdas</a></li>
<li class="toctree-l1"><a class="reference internal" href="linq.html">99. LINQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="abstraction.html">100. Abstraction / Modeling</a></li>
<li class="toctree-l1"><a class="reference internal" href="indirection.html">101. Indirection</a></li>
<li class="toctree-l1"><a class="reference internal" href="business-logic.html">102. Business logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="business-objects.html">103. Business objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="debugging.html">104. Debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="reading.html">105. Suggested reading</a></li>
<li class="toctree-l1"><a class="reference internal" href="bibliography.html">106. Bibliography</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section class="tex2jax_ignore mathjax_ignore" id="type-systems">
<h1>Type systems<a class="headerlink" href="#type-systems" title="Permalink to this heading">#</a></h1>
<section id="motivation">
<h2>Motivation<a class="headerlink" href="#motivation" title="Permalink to this heading">#</a></h2>
<p>C# is a statically and nominally typed language with manifested types.
In this chapter we’ll talk about what that means.
A type system lets us assign a type to each, so called, term, in a program.
In C#, all <a class="reference internal" href="variables.html"><span class="doc std std-doc">variables</span></a>, <a class="reference internal" href="constants.html"><span class="doc std std-doc">constants</span></a>, <a class="reference internal" href="expressions.html"><span class="doc std std-doc">expressions that return values</span></a>, and methods have a type.</p>
</section>
<section id="definition">
<h2>Definition<a class="headerlink" href="#definition" title="Permalink to this heading">#</a></h2>
<p>A language with types is said to have a type system and type systems can be classified in a number of dimensions that we’ll discuss in this chapter.</p>
<ul class="simple">
<li><p>A type system is either <a class="reference internal" href="#static-vs-dynamic"><span class="std std-ref">statically or dynamically typed</span></a>. This is also simply known as static or dynamic and refers to whether type-checking occurs at compile-time or at run-time.</p></li>
<li><p>Types in a typed language are either <a class="reference internal" href="#manifested-vs-inferred"><span class="std std-ref">manifested or inferred</span></a>. This regards whether types are explicitly stated in the code by the programmer or whether the types are automatically inferred by the type-checker. You can think of the latter case as the compiler figuring out whatever types must have been used where.</p></li>
<li><p>Types in a typed language are either <a class="reference internal" href="#nominal-vs-structural"><span class="std std-ref">nominal, structural, or duck typed</span></a>. This refers to whether types are distinguished from one another by means of their names, their structure, or their usage.</p></li>
</ul>
<section id="static-vs-dynamic">
<span id="type-safety"></span><span id="id1"></span><h3>Static vs dynamic<a class="headerlink" href="#static-vs-dynamic" title="Permalink to this heading">#</a></h3>
<p>Whether a language is statically typed or dynamically typed dictates whether <a class="reference internal" href="type-checking.html"><span class="doc std std-doc">type-checking</span></a> occurs at <a class="reference internal" href="compilation.html"><span class="doc std std-doc">compile-time</span></a> or at <a class="reference internal" href="execution.html"><span class="doc std std-doc">run-time</span></a>.
Colloquially we refer to this as the language being static or dynamic.</p>
<p>Hopefully you can recall how we, in the chapter on <span class="xref myst">errors</span> discussed that compile-time errors ought to be preferred over run-time errors since they guarantee that anytime we see a compile-time error we are saved from all errors that could occur as a consequence of this but at run-time, meaning when the application is running.</p>
<p>By the same token, static typing ought to be preferred over dynamic typing since it gives us type-safety at compile-time instead of at run-time.
Meaning that anytime we get a type error at compile-time we are saved from all other errors that could occur as a consequence of this but at run-time, meaning when the application is running.</p>
<p>Some statically typed languages, such as C#, does however provide ways of leaving the realm of static typing at your request.
In C# we have the special type <code class="docutils literal notranslate"><span class="pre">dynamic</span></code> which can hold any run-time type.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">dynamic</span><span class="w"> </span><span class="n">v1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span>
<span class="kt">dynamic</span><span class="w"> </span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="p">;</span>
<span class="kt">dynamic</span><span class="w"> </span><span class="n">v3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">true</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
<div>
    <div id='dotnet-interactive-this-cell-5525.Microsoft.DotNet.Interactive.Http.HttpPort' style='display: none'>
        The below script needs to be able to find the current output cell; this is an easy method to get it.
    </div>
    <script type='text/javascript'>
async function probeAddresses(probingAddresses) {
    function timeout(ms, promise) {
        return new Promise(function (resolve, reject) {
            setTimeout(function () {
                reject(new Error('timeout'))
            }, ms)
            promise.then(resolve, reject)
        })
    }

    if (Array.isArray(probingAddresses)) {
        for (let i = 0; i < probingAddresses.length; i++) {

            let rootUrl = probingAddresses[i];

            if (!rootUrl.endsWith('/')) {
                rootUrl = `${rootUrl}/`;
            }

            try {
                let response = await timeout(1000, fetch(`${rootUrl}discovery`, {
                    method: 'POST',
                    cache: 'no-cache',
                    mode: 'cors',
                    timeout: 1000,
                    headers: {
                        'Content-Type': 'text/plain'
                    },
                    body: probingAddresses[i]
                }));

                if (response.status == 200) {
                    return rootUrl;
                }
            }
            catch (e) { }
        }
    }
}

function loadDotnetInteractiveApi() {
    probeAddresses(["http://10.1.1.137:2048/", "http://127.0.0.1:2048/"])
        .then((root) => {
        // use probing to find host url and api resources
        // load interactive helpers and language services
        let dotnetInteractiveRequire = require.config({
        context: '5525.Microsoft.DotNet.Interactive.Http.HttpPort',
                paths:
            {
                'dotnet-interactive': `${root}resources`
                }
        }) || require;

            window.dotnetInteractiveRequire = dotnetInteractiveRequire;

            window.configureRequireFromExtension = function(extensionName, extensionCacheBuster) {
                let paths = {};
                paths[extensionName] = `${root}extensions/${extensionName}/resources/`;
                
                let internalRequire = require.config({
                    context: extensionCacheBuster,
                    paths: paths,
                    urlArgs: `cacheBuster=${extensionCacheBuster}`
                    }) || require;

                return internalRequire
            };
        
            dotnetInteractiveRequire([
                    'dotnet-interactive/dotnet-interactive'
                ],
                function (dotnet) {
                    dotnet.init(window);
                },
                function (error) {
                    console.log(error);
                }
            );
        })
        .catch(error => {console.log(error);});
    }

// ensure `require` is available globally
if ((typeof(require) !==  typeof(Function)) || (typeof(require.config) !== typeof(Function))) {
    let require_script = document.createElement('script');
    require_script.setAttribute('src', 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js');
    require_script.setAttribute('type', 'text/javascript');
    
    
    require_script.onload = function() {
        loadDotnetInteractiveApi();
    };

    document.getElementsByTagName('head')[0].appendChild(require_script);
}
else {
    loadDotnetInteractiveApi();
}

    </script>
</div></div></div>
</div>
<p>Like in some dynamically typed languages, the value does however still have a run-time type.
Check out the code example below where we check the types of the <code class="docutils literal notranslate"><span class="pre">dynamic</span></code> variables declared above.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="w"> </span><span class="n">v1</span><span class="p">.</span><span class="n">GetType</span><span class="p">()</span><span class="w"> </span><span class="p">);</span>
<span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="w"> </span><span class="n">v2</span><span class="p">.</span><span class="n">GetType</span><span class="p">()</span><span class="w"> </span><span class="p">);</span>
<span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="w"> </span><span class="n">v3</span><span class="p">.</span><span class="n">GetType</span><span class="p">()</span><span class="w"> </span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>System.Int32
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>System.String
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>System.Boolean
</pre></div>
</div>
</div>
</div>
<p>Using the keyword <code class="docutils literal notranslate"><span class="pre">dynamic</span></code> consequently doesn’t mean that we move from a world of multiple types into a world of no types at all.
It means that we move to a uni-typed world where there is only a single compile-time type, namely the type <code class="docutils literal notranslate"><span class="pre">dynamic</span></code>.</p>
<p>The compiler assumes that values given the compile-time type <code class="docutils literal notranslate"><span class="pre">dynamic</span></code> supports any operation.
This means that all operations will be allowed at compile-time.
If we invoke an operation that does in fact also exist in the run-time type, the program will compile and run.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">dynamic</span><span class="w"> </span><span class="n">x1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span>
<span class="kt">dynamic</span><span class="w"> </span><span class="n">x2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span>
<span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">x1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x2</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2
</pre></div>
</div>
</div>
</div>
<p>If however we invoke an operation that does <em>not</em> exist in the run-time type we then the program will still compile but it will crash with an exception at run-time.
We can get a run-time error if we call a method that doesn’t exist:</p>
<div class="cell tag_raises-exception docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">dynamic</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span>
<span class="n">z</span><span class="p">.</span><span class="n">FlyToTheMoon</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span>Microsoft.CSharp.RuntimeBinder.RuntimeBinderException: &#39;int&#39; does not contain a definition for &#39;FlyToTheMoon&#39;
   at CallSite.Target(Closure, CallSite, Object)
   at System.Dynamic.UpdateDelegates.UpdateAndExecuteVoid1[T0](CallSite site, T0 arg0)
   at Submission#6.&lt;&lt;Initialize&gt;&gt;d__0.MoveNext()
--- End of stack trace from previous location ---
   at Microsoft.CodeAnalysis.Scripting.ScriptExecutionState.RunSubmissionsAsync[TResult](ImmutableArray`1 precedingExecutors, Func`2 currentExecutor, StrongBox`1 exceptionHolderOpt, Func`2 catchExceptionOpt, CancellationToken cancellationToken)
   at CallSite.Target(Closure, CallSite, Object)
   at System.Dynamic.UpdateDelegates.UpdateAndExecuteVoid1[T0](CallSite site, T0 arg0)
   at Submission#6.&lt;&lt;Initialize&gt;&gt;d__0.MoveNext()
--- End of stack trace from previous location ---
   at Microsoft.CodeAnalysis.Scripting.ScriptExecutionState.RunSubmissionsAsync[TResult](ImmutableArray`1 precedingExecutors, Func`2 currentExecutor, StrongBox`1 exceptionHolderOpt, Func`2 catchExceptionOpt, CancellationToken cancellationToken)
</pre></div>
</div>
</div>
</div>
<p>But we can also get a run-time error if we use a value with an operator that isn’t supported:</p>
<div class="cell tag_raises-exception docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">dynamic</span><span class="w"> </span><span class="n">y1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span>
<span class="kt">dynamic</span><span class="w"> </span><span class="n">y2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">true</span><span class="p">;</span>

<span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y2</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span>Microsoft.CSharp.RuntimeBinder.RuntimeBinderException: Operator &#39;+&#39; cannot be applied to operands of type &#39;int&#39; and &#39;bool&#39;
   at CallSite.Target(Closure, CallSite, Object, Object)
   at System.Dynamic.UpdateDelegates.UpdateAndExecute2[T0,T1,TRet](CallSite site, T0 arg0, T1 arg1)
   at Submission#7.&lt;&lt;Initialize&gt;&gt;d__0.MoveNext()
--- End of stack trace from previous location ---
   at Microsoft.CodeAnalysis.Scripting.ScriptExecutionState.RunSubmissionsAsync[TResult](ImmutableArray`1 precedingExecutors, Func`2 currentExecutor, StrongBox`1 exceptionHolderOpt, Func`2 catchExceptionOpt, CancellationToken cancellationToken)
   at CallSite.Target(Closure, CallSite, Object, Object)
   at System.Dynamic.UpdateDelegates.UpdateAndExecute2[T0,T1,TRet](CallSite site, T0 arg0, T1 arg1)
   at Submission#7.&lt;&lt;Initialize&gt;&gt;d__0.MoveNext()
--- End of stack trace from previous location ---
   at Microsoft.CodeAnalysis.Scripting.ScriptExecutionState.RunSubmissionsAsync[TResult](ImmutableArray`1 precedingExecutors, Func`2 currentExecutor, StrongBox`1 exceptionHolderOpt, Func`2 catchExceptionOpt, CancellationToken cancellationToken)
</pre></div>
</div>
</div>
</div>
</section>
<section id="manifested-vs-inferred">
<span id="id2"></span><h3>Manifested vs inferred<a class="headerlink" href="#manifested-vs-inferred" title="Permalink to this heading">#</a></h3>
<p>Whether a type system uses manifested or inferred types dictates whether we, as programmers, have to explicitly state the types in our programs or whether they are inferred by the compiler.</p>
<p>Very few languages are fully inferred.
Instead, languages are usually only inferred to a certain extent, beyond which you still have to manifest the types since the type inference engine is unable to infer them.
This is a consequence of the sophistication of both the type system and the inference engine.</p>
<p>C# is traditionally a language with manifested types but we can declare, what’s known as, “implicitly typed local variables” which have inferred types.
We declare such variables by using the keyword <code class="docutils literal notranslate"><span class="pre">var</span></code> instead of the type of the variable in question.</p>
<p>In the example below, the type of the first variable is manifested while the type of the second variable is inferred.
The compile-time type of both is <code class="docutils literal notranslate"><span class="pre">int</span></code>.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">i1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// Explicitly typed (manifested)</span>
<span class="kt">var</span><span class="w"> </span><span class="n">i2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// Implicitly typed (inferred)</span>
</pre></div>
</div>
<p>It is important to realize that type inference <em>infers</em> types.
Type inference does <em>not</em> mean that we completely ignore neither compile-time nor run-time types.
The two compile-time types in the example above are just as “strong”.
The fact that one of the types is inferred while the other is manifested is irrelevant.</p>
<p>In the last section, where we discussed static and dynamic, we said that in C# we can use the keyword <code class="docutils literal notranslate"><span class="pre">dynamic</span></code> to bypass static typing.
When using the <code class="docutils literal notranslate"><span class="pre">dynamic</span></code> keyword we make the compile-time type <code class="docutils literal notranslate"><span class="pre">dynamic</span></code>.
But, when using the <code class="docutils literal notranslate"><span class="pre">var</span></code> keyword, we use type inference and let the compiler figure out what compile-time type must be used to make the program compile.
This is not the same thing.</p>
<p>When is it useful to use type inference instead of manifesting types in C#?
One use case it to avoid cluttering up our code with the names of very long type names.
We haven’t talked about these types but say you’re trying to modeling a chess board as a list of lists of positions.
A list of lists is sometimes also called a two-dimensional lists and is commonly used to represent a grid.</p>
<p>When declaring such a variable we specify the compile-time type on the left and then assign it a value with a run-time type on the right.
If we manifest the type it would look something like this:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Position</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">board1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Position</span><span class="o">&gt;&gt;&gt;</span><span class="p">();</span>
</pre></div>
</div>
<p>However, since the compile-time type is the same as the run-time type, or in other words, since the type on the left is the same as the type on the right this is a prime use case for type inference.
By using an implicitly typed local variable on the left our code is significantly less cluttered and arguably easier to read.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="w"> </span><span class="n">board2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Piece</span><span class="o">&gt;&gt;&gt;</span><span class="p">();</span>
</pre></div>
</div>
<p>The compile-time type of both variables is still the same since this is type inference, not dynamic typing.
The keyword <code class="docutils literal notranslate"><span class="pre">var</span></code> is often also used in <a class="reference internal" href="iteration.html"><span class="doc std std-doc"><code class="docutils literal notranslate"><span class="pre">foreach</span></code> loops</span></a> which we will learn about later.</p>
<p>It should be noted that in the example above, the usage of an implicitly typed local variable (<code class="docutils literal notranslate"><span class="pre">var</span></code>) is optional.
However, when you have a value with an <a class="reference internal" href="anonymous-types.html#anonymous-types"><span class="std std-ref">anonymous type</span></a>, using <code class="docutils literal notranslate"><span class="pre">var</span></code> is required.
We’ll talk more about anonymous types in its own chapter, but for now I just wanted to mention that when you deal with anonymous types, you might have to use <code class="docutils literal notranslate"><span class="pre">var</span></code>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>See the <a class="reference external" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/var">official documentation</a> for more information about implicitly typed local variables (the keyword <code class="docutils literal notranslate"><span class="pre">var</span></code>).</p>
</div>
</section>
<section id="nominal-vs-structural">
<span id="id3"></span><h3>Nominal vs structural<a class="headerlink" href="#nominal-vs-structural" title="Permalink to this heading">#</a></h3>
<p>The third dimension in which we can classify a type system is in whether its types are nominal or structural.
Whether the type system is nominal or structural.
Again, many languages are mixes of the two but it’s easier to understand the concepts if we look at the extremes.
C# is mostly a nominally typed language but “anonymous types” (see <a class="reference external" href="https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/types/anonymous-types">documentation</a>) are arguably structurally typed.</p>
<p>The key question we’re dealing with when we’re dealing with nominal and structural typing is substitutability.
Can a particular type be used in a particular place?
More specifically we tend to talk about equivalence and subtyping.
Equivalence regards whether two types are equal while subtyping regards whether one type is a subtype of another.
We have yet to talk about <a class="reference internal" href="subtype-polymorphism.html"><span class="doc std std-doc">subtype polymorphism</span></a> so this is a bit too much too soon but think of it this way:
To determine whether a particular type can be used in a particular place we must either prove that the type of the value that we have is equivalent to the type that is expected, or we must prove that the type of the value that we have is a subtype of the type that is expected.</p>
<p>With nominal types, equivalence and subtyping is determined by means of names.
With structural types, equivalence and subtyping is determined by means of structure.</p>
<p>Every nominal type has a name and it is this name that we use to determine equivalence.
If we declare that a type is a subtype of another type then we declare that one name is a subtype of another name.
Hence, we can use the names and subtype information to determine whether a nominal type is a subtype of another nominal type.</p>
<p>Structural types on the other hand don’t need names since equivalence and subtyping is determined on the basis of structure.
If the type we need must have some properties, then we simply check whether these properties exist in the type that we have.
If the properties are present then the type that we have is deemed equivalent to the type that we need, and hence can be used.
If the properties are present but the type also has additional properties then it is considered a subtype.</p>
<p>In a structural typing system, a type can be equal to and be a subtype of many other types simultaneously.
In nominal typing two types are only ever equal if they are the same type and they are only ever in a subtype relationship if said relationship has been explicitly defined.</p>
<p>However, as an aside, in nominally typed languages it is usually not possible to let a type be a subtype of another if the type is not also “wider” than the subtype.
Consequently, nominal subtypes are also usually structural subtypes.</p>
</section>
<section id="duck-typing">
<h3>Duck typing<a class="headerlink" href="#duck-typing" title="Permalink to this heading">#</a></h3>
<p>Before we leave this chapter we must also talk about something known as duck typing.
Some argue that duck typing is another point on the dimension where we find structural and nominal typing.
Others hold that duck typing is a special case of structural typing.</p>
<p>The name “duck typing” refers to the saying:</p>
<blockquote class="epigraph">
<div><p>If it quacks like a duck, it must be a duck.</p>
</div></blockquote>
<p>In duck typing, the idea is that it doesn’t matter what something “is”, it only matters what it “does”.
Contrast this to structural typing.
Structural typing determines suitability of a type based on the full structure of the type.
But duck typing determines suitability of a type based on the properties used at run-time.</p>
<p>If we ask something whether it can quack and it can, then it doesn’t really matter if it’s a duck or not.
For our intents and purposes it behaves like a duck so let’s just keep using it like one.</p>
<p>Duck typing is usually employed in dynamic languages such as for example Ruby and JavaScript.
We’re not diving into Ruby or JavaScript in this book but here’s an example in Ruby.</p>
<div class="highlight-ruby notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Duck</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">quack</span>
<span class="w">    </span><span class="nb">puts</span><span class="w"> </span><span class="s2">&quot;Quack&quot;</span>
<span class="w">  </span><span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Robot</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">quack</span>
<span class="w">    </span><span class="nb">puts</span><span class="w"> </span><span class="s2">&quot;Brrr&quot;</span>
<span class="w">  </span><span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test</span><span class="w"> </span><span class="n">duck</span>
<span class="w">  </span><span class="n">duck</span><span class="o">.</span><span class="n">quack</span>
<span class="k">end</span>

<span class="nb">test</span><span class="w"> </span><span class="no">Duck</span><span class="o">.</span><span class="n">new</span>
<span class="nb">test</span><span class="w"> </span><span class="no">Robot</span><span class="o">.</span><span class="n">new</span>
</pre></div>
</div>
<div class="highlight-output notranslate"><div class="highlight"><pre><span></span><span class="go">Quack</span>
<span class="go">Brrr</span>
</pre></div>
</div>
<p>In the example above we’re defining two types called <code class="docutils literal notranslate"><span class="pre">Duck</span></code> and <code class="docutils literal notranslate"><span class="pre">Robot</span></code>.
We’re defining a method called <code class="docutils literal notranslate"><span class="pre">test</span></code> which takes an argument and calls the method <code class="docutils literal notranslate"><span class="pre">quack</span></code> on that argument.
We’re then instantiating one duck and one robot and pass both of them to the <code class="docutils literal notranslate"><span class="pre">test</span></code> method.
Since both objects respond to the <code class="docutils literal notranslate"><span class="pre">quack</span></code> method we conclude that both are ducks.
There is no point in arguing about whether robots are not ducks.
For all intents and purposes they behave like ducks.</p>
<p>When you’ve read the chapter on <a class="reference internal" href="interfaces.html"><span class="doc std std-doc">interfaces</span></a> I highly recommend that you come back to this chapter again and think about the relationship between duck types and interfaces.</p>
</section>
</section>
<section id="exercises">
<h2>Exercises<a class="headerlink" href="#exercises" title="Permalink to this heading">#</a></h2>
<div class="exercise admonition" id="chapters/type-systems-exercise-0">

<p class="admonition-title"></p>
<section id="exercise-content">
<p>What is the difference between statically typed and dynamically typed languages?</p>
</section>
</div>
<div class="exercise admonition" id="chapters/type-systems-exercise-1">

<p class="admonition-title"></p>
<section id="exercise-content">
<p>What is the difference between manifested types and inferred types?
What does this difference mean in terms of compile-time and run-time types?</p>
</section>
</div>
<div class="exercise admonition" id="chapters/type-systems-exercise-2">

<p class="admonition-title"></p>
<section id="exercise-content">
<p>Can a language be statically typed yet still have mostly inferred types? Why?</p>
</section>
</div>
<div class="exercise admonition" id="chapters/type-systems-exercise-3">

<p class="admonition-title"></p>
<section id="exercise-content">
<p>What is the difference between a nominal and a structural type system?</p>
</section>
</div>
<div class="exercise admonition" id="chapters/type-systems-exercise-4">

<p class="admonition-title"></p>
<section id="exercise-content">
<p>What is duck typing? How does it relate to structural typing?</p>
</section>
</div>
<div class="exercise admonition" id="chapters/type-systems-exercise-5">

<p class="admonition-title"></p>
<section id="exercise-content">
<p>What is the following maxim trying to convey?
“If it quacks like a duck, it must be a duck.”</p>
</section>
</div>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: ".net-csharp"
        },
        kernelOptions: {
            name: ".net-csharp",
            path: "./chapters"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = '.net-csharp'</script>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Type systems</a><ul>
<li><a class="reference internal" href="#motivation">Motivation</a></li>
<li><a class="reference internal" href="#definition">Definition</a><ul>
<li><a class="reference internal" href="#static-vs-dynamic">Static vs dynamic</a></li>
<li><a class="reference internal" href="#manifested-vs-inferred">Manifested vs inferred</a></li>
<li><a class="reference internal" href="#nominal-vs-structural">Nominal vs structural</a></li>
<li><a class="reference internal" href="#duck-typing">Duck typing</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exercises">Exercises</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script src="https://www.googletagmanager.com/gtag/js?id=G-V69WNXD095"></script>
    <script src="../_static/custom.js"></script>
    <script src="../_static/analytics.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js"></script>
    <script src="../_static/scripts/furo.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    </body>
</html>