<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />
<link rel="index" title="Index" href="../genindex.html" /><link rel="search" title="Search" href="../search.html" />

    <!-- Generated with Sphinx 5.0.2 and Furo 2023.03.27 -->
        <title>Objects (old) - The Object Oriented Way</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?digest=fad236701ea90a88636c2a8c73b44ae642ed2a53" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/exercise.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    <link rel="stylesheet" type="text/css" href="../_static/style.css" />
    
    


<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">The Object Oriented Way</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand centered" href="../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo" src="../_static/logo.png" alt="Logo"/>
  </div>
  
  <span class="sidebar-brand-text">The Object Oriented Way</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Chapters</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../chapters/syntax.html">1. Syntax</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/hello-world.html">2. Hello world</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/compilation.html">3. Compilation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/execution.html">4. Execution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/interpretation.html">5. Interpretation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/comments.html">6. Comments</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/values.html">7. Values</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/variables.html">8. Variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/data-types.html">9. Data types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/expressions.html">10. Expressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/arithmetic-operators.html">11. Arithmetic operators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/equality-operators.html">12. Equality operators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/relational-operators.html">13. Relational operators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/logical-operators.html">14. Logical operators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/assignment-operator.html">15. Assignment operator</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/precedence.html">16. Precedence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/associativity.html">17. Associativity</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/constants.html">18. Constants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/statements.html">19. Statements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/type-inference.html">20. Type inference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/type-checking.html">21. Type checking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/floating-point-types.html">22. Floating-point types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/enumeration-types.html">23. Enumeration types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/selection-statements.html">24. Selection statements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/selection-expressions.html">25. Selection expressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/iteration.html">26. Iteration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/arrays.html">27. Arrays</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/reference-types.html">28. Reference types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/value-types.html">29. Value types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/local-functions.html">30. Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/fat-arrows.html">31. Fat arrows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/recursion.html">32. Recursion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/namespaces.html">33. Namespaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/objects.html">34. Objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/classes.html">35. Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/access-modifiers.html">36. Access modifiers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/fields.html">37. Fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/constructors.html">38. Constructors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/the-this-keyword.html">39. The <code class="docutils literal notranslate"><span class="pre">this</span></code> keyword</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/instance-methods.html">40. Instance methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/encapsulation.html">41. Encapsulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/auto-implemented-properties.html">42. Auto-implemented properties</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/manually-implemented-properties.html">43. Manually implemented properties</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/object-initializers.html">44. Object initializers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/read-only-fields.html">45. Read-only fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/read-only-properties.html">46. Read-only properties</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/computed-properties.html">47. Computed properties</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/required-properties-and-fields.html">48. Required properties and fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/init-only-properties.html">49. Init-only properties</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/instance-method-overloading.html">50. Instance method overloading</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/constructor-overloading.html">51. Constructor overloading</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/static-fields.html">52. Static fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/static-constructors.html">53. Static constructors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/static-methods.html">54. Static methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/static-properties.html">55. Static properties</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/static-classes.html">56. Static classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/top-level-statements.html">57. Top-level statements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/object-composition.html">58. Object composition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/interfaces.html">59. Interfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/subtype-polymorphism.html">60. Subtype polymorphism</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/run-time-type-vs-compile-time-type.html">61. Run-time type vs compile-time type</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/dynamic-dispatch.html">62. Dynamic dispatch</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/multiple-interfaces.html">63. Multiple interfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/interface-default-implementations.html">64. Interface default implementations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/inheritance.html">65. Inheritance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/overriding.html">66. Overriding</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/hiding.html">67. Hiding</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/the-base-keyword.html">68. The <code class="docutils literal notranslate"><span class="pre">base</span></code> keyword</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/constructor-chaining.html">69. Constructor chaining</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/protected.html">70. Protected access modifier</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/abstract-classes.html">71. Abstract classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/interface-inheritance.html">72. Interface inheritance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/type-conversions.html">73. Type conversions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/upcasting.html">74. Upcasting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/downcasting.html">75. Downcasting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/everything-is-an-object.html">76. Everything is an object</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/uml-class-diagrams.html">77. UML class diagrams</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/maintainability.html">78. Maintainability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/refactoring.html">79. Refactoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/generics.html">80. Generics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/generic-types.html">81. Generic types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/generics-and-type-errors.html">82. Generics and type errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/generic-supertypes.html">83. Generic supertypes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/generic-methods.html">84. Generic methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/type-parameter-constraints.html">85. Type parameter constraints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/collections.html">86. Collections</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/collection-initializers.html">87. Collection initializers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/replace-conditional-with-polymorphism.html">88. Replace conditional with polymorphism</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/dependency-injection.html">89. Dependency injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/composition-over-inheritance.html">90. Composition over inheritance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/strategy-pattern.html">91. Strategy pattern</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/bridge-pattern.html">92. Bridge pattern</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/delegates.html">93. Delegates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/generic-delegates.html">94. Generic delegates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/built-in-delegates.html">95. Built-in delegates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/multicast-delegates.html">96. Multicast delegates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/lambdas.html">97. Lambdas</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/observer-pattern.html">98. Observer pattern</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/events.html">99. Events</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/event-conventions.html">100. Event conventions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/event-driven-programming.html">101. Event-driven programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/iterator-pattern.html">102. Iterator pattern</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/enumerables.html">103. Enumerables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/the-yield-statement.html">104. The <code class="docutils literal notranslate"><span class="pre">yield</span></code> statement</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/anonymous-types.html">105. Anonymous types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/linq.html">106. LINQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/variance.html">107. Variance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/covariance.html">108. Covariance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/contravariance.html">109. Contravariance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/invariance.html">110. Invariance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/liskov-substitution-principle.html">111. Liskov substitution principle</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/variant-classes.html">112. Variant classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/variant-delegates.html">113. Variant delegates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/variant-generic-delegates.html">114. Variant generic delegates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/variant-generic-interfaces.html">115. Variant generic interfaces</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Labs</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../labs/replace-conditional-with-polymorphism.html">Lab: Replace conditional with polymorphism</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/generics.html">Lab: Generics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/generic-types.html">Lab: Generic types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/generic-supertypes.html">Lab: Generic Supertypes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/type-parameter-constraints.html">Lab: Type parameter constraints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/composition-over-inheritance.html">Lab: Composition over Inheritance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/bridge-pattern.html">Lab: Bridge Pattern</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/delegates.html">Lab: Delegates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/lambdas.html">Lab: Lambdas</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/observer-pattern.html">Lab: Observer Pattern</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/events.html">Lab: Events</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/iterator-pattern.html">Lab: Iterator pattern</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/enumerables.html">Lab: Enumerables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/the-yield-keyword.html">Lab: The <code class="docutils literal notranslate"><span class="pre">yield</span></code> keyword</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/variant-classes.html">Lab: Variant classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/variant-delegates.html">Lab: Variant delegates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/variant-generic-delegates.html">Lab: Variant Generic Delegates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/variant-generic-interfaces.html">Lab: Variant Generic Interfaces</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section class="tex2jax_ignore mathjax_ignore" id="objects-old">
<h1>Objects (old)<a class="headerlink" href="#objects-old" title="Permalink to this heading">#</a></h1>
<p>Let us now explore the idea of objects.
In the next chapter we will talk about <span class="xref myst">classes</span> but let’s now focus strictly on objects.</p>
<section id="motivation">
<h2>Motivation<a class="headerlink" href="#motivation" title="Permalink to this heading">#</a></h2>
<p>In procedural programming, the building block is the <a class="reference internal" href="method-composition.html"><span class="doc std std-doc">procedure</span></a>.
<strong>In object oriented programming, the building block is the object.</strong>
In procedural programming, we solve complex problems by composing simple procedures.
In object oriented programming, we solve complex problems by composing simple objects.
<a class="reference internal" href="object-composition.html"><span class="doc std std-doc">Object composition</span></a> is something that we’ll discuss at length in future chapters.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>The fundamental building block in object oriented programming is the object.</p>
</div>
<p>Remember how we, in the chapter on <span class="xref myst">methods</span>, discussed that with methods as the only abstraction and method composition as the only tool (and assuming that we don’t have access to things such as parametric polymorphism and higher order functions) we will be forced to eventually turn methods into data to increase abstractions.</p>
<p>What I mean is that to increase the modularity of our code, and hence eliminate duplication, we will have to take things that might otherwise be expressed as methods and somehow convert them into data that methods can operate upon.
In other words, instead of just implementing whatever code we want to implement as a method, we have to figure out how to represent some key step or steps (where there are multiple possible algorithms) as a data type that we then can accept as a parameter.
When passing different values as arguments we get different behavior.
All this for the purpose of eliminating duplication by increasing abstraction.</p>
<p>A good example of this is how we, in the chapter on <a class="reference internal" href="../chapters/methods-old.html#methods-substitutions"><span class="std std-ref">methods</span></a>, found ourselves in a position where it was difficult to increase abstraction and eliminate duplication without expressing part of the algorithm as data.
We figured out that some ciphers are substitution ciphers and that the substitutions that any particular cipher performs can be expressed as an array of pairs containing a pattern and a replacement.</p>
<p>Instead of being able to write algorithms called <code class="docutils literal notranslate"><span class="pre">robbersEncodeString</span></code>, <code class="docutils literal notranslate"><span class="pre">leetEncodeString</span></code>, and so forth, we had to write a method called <code class="docutils literal notranslate"><span class="pre">substitute</span></code> that accepted a list of substitutions instead.
The substitutions are now data instead of being part of the algorithm.</p>
<p>This is not necessarily a bad thing.
It all depends on what you want to achieve and what you prefer.</p>
<p>However, sometimes it’s really difficult to find a sensible way of representing an algorithm as data.
Not all algorithms can trivially be represented as data.
In the case of substitution ciphers it happened to be simple.
But some algorithms are arguably easier to express as methods.</p>
<p>Back in the days, this is where function pointers would come into play.
But, pointers are not <a class="reference internal" href="../chapters/type-systems.html#type-safety"><span class="std std-ref">type safe</span></a> and by now I’m hoping that you’re convinced that static type safety is really important.
So, let’s not dwell on the archeic concept of function pointers.
But what then?</p>
<p>Well, this is where objects enter the scene.
Objects allow us to bundle up some data with some methods and then <em>send that bundle</em> around.
As we will learn, objects allow <a class="reference internal" href="subtype-polymorphism.html"><span class="doc std std-doc">subtype polymorphism</span></a> and hence <a class="reference internal" href="subtype-polymorphism.html#dynamic-dispatch"><span class="std std-ref">dynamic dispatch</span></a> without loosing static type safety.
This in turn allows us to keep increasing abstraction without having to resort to turning more and more algorithms into data.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In the coming chapters we will mostly focus on the idea of writing the substitution algorithms ourselves rather than turning the substitutions into data.
But rest assured that when we’re done rewriting this in a more object oriented fashion we’ll also be able to support both ideas at the same time.
So if you really liked the idea of substitution ciphers, don’t worry.</p>
</div>
</section>
<section id="definition">
<h2>Definition<a class="headerlink" href="#definition" title="Permalink to this heading">#</a></h2>
<p>So what is an object?
Well, there’s basically two camps.
The fundamentalists and the practical bunch.</p>
<p>The fundamentalists hold that objects are (possibly stateful) agents that you can interact with by sending messages and receiving responses.
They hold that message passing is a philosophy, and that by following the way of the message we will write better programs.</p>
<p>The practical bunch, argue that an object is just a bunch of methods (known as <a class="reference internal" href="instance-methods.html"><span class="doc std std-doc">instance methods</span></a>) that operate on some <a class="reference internal" href="#encapsulation"><span class="std std-ref">encapsulated</span></a> state (known as <a class="reference internal" href="fields.html"><span class="doc std std-doc">instance fields</span></a>).</p>
<p>I myself happen to symphatize with the more practical view.
There’s nothing magical, mystical, or philosophical about object oriented programming.
It’s just a way of giving us <a class="reference internal" href="subtype-polymorphism.html#dynamic-dispatch"><span class="std std-ref">single dynamic dispatch</span></a> by means of <a class="reference internal" href="subtype-polymorphism.html"><span class="doc std std-doc">subtype polymorphism</span></a> without loosing <a class="reference internal" href="../chapters/type-systems.html#type-safety"><span class="std std-ref">static type-safety</span></a>.
If that sentence doesn’t make any sense to you, don’t worry.
When you’re done reading this book, it will.</p>
<section id="information-hiding">
<span id="encapsulation"></span><span id="id1"></span><h3>Encapsulation<a class="headerlink" href="#information-hiding" title="Permalink to this heading">#</a></h3>
<p>Objects mix methods and data in order to hide the data that belongs to a particular object so that other objects cannot accidentally change it.
This is known as “encapsulation” or “information hiding”.</p>
<p>The two terms are, today, often considered synonymous.
Originally though, they may have been used to describe different things.
If you are interested in learning more about the different definitions of <em>encapsulation</em> and <em>information hiding</em> I highly recomend reading this answer on <a class="reference external" href="https://stackoverflow.com/a/39499367">Stack Overflow</a>.</p>
<p>The short story is that encapsulation sometimes simply refers to the idea of mixing methods and data, while information hiding sometimes more specifically refers to the idea of making the object that encapsulates the data the only one able to change the data.
In other words, information hiding makes it impossible for data in an object to be changed by objects of other types.
The following saying is a cheeky way to remember the idea of information hiding:</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Hide your private parts.</p>
</div>
<p>We say that objects encapsulate or hide state.
That they hide their private parts.
That objects are a set of methods that operate on some encapsulated state?
But what do we mean by all this?</p>
<p>Let’s say that we’re passing around two integers that correspond to some <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> coordinates of some <code class="docutils literal notranslate"><span class="pre">player</span></code> in some game that we’re building.
Let’s then say that we’ve got a bunch of methods like <code class="docutils literal notranslate"><span class="pre">moveEast</span></code> and <code class="docutils literal notranslate"><span class="pre">moveNorthEast</span></code> that we use to update these coordinates.
Doing this the object oriented way we would encapsulate the <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> coordinates in an object whose type we might call <code class="docutils literal notranslate"><span class="pre">Position</span></code>.
We might also encapsulate the position object itself in an object whose type we might call <code class="docutils literal notranslate"><span class="pre">Player</span></code>.
The methods <code class="docutils literal notranslate"><span class="pre">moveEast</span></code> and <code class="docutils literal notranslate"><span class="pre">moveNorthEast</span></code> would now likely become instance methods on the objects of type <code class="docutils literal notranslate"><span class="pre">Player</span></code> and <code class="docutils literal notranslate"><span class="pre">Position</span></code>.
These instance methods update the state that’s been encapsulated in the objects.</p>
<figure class="margin align-default" id="id4">
<img alt="https://m.media-amazon.com/images/I/41-sN-mzwKL._SX381_BO1,204,203,200_.jpg" src="https://m.media-amazon.com/images/I/41-sN-mzwKL._SX381_BO1,204,203,200_.jpg" />
<figcaption>
<p><span class="caption-text"><a class="reference external" href="http://amazon.christopherokhravi.com?id=0134494164">Clean Architecture, by Robert C. Martin</a>.</span><a class="headerlink" href="#id4" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>It is my duty however, to mention that some authors, like Robert C. Martin (see for example <span id="id2">Martin [<a class="reference internal" href="../chapters/bibliography.html#id4" title="R. C. Martin. Clean Architecture: A Craftsman's Guide to Software Structure and Design. Robert C. Martin Series. Pearson Education, 2017. ISBN 9780134494326. URL: https://geni.us/IBhtLnh.">2017</a>]</span>), argues that the mixing of methods and data isn’t unique to object oriented programming.
Instead, he proposes that the defining feature of object oriented languages is that they make subtype polymorphism type safe at compile-time.
This is the same argument we made in the motivation section of this chapter.</p>
</section>
<section id="message-passing">
<span id="id3"></span><h3>Message passing<a class="headerlink" href="#message-passing" title="Permalink to this heading">#</a></h3>
<p>Ok, so what is this idea of message passing?
Pessimistically, a message is nothing more than a call to an <a class="reference internal" href="instance-methods.html"><span class="doc std std-doc">instance method</span></a>.
We’ll talk about instance methods in a separate chapter but in short, they are just regular methods that are executed within the context of the state of an object.
Meaning that instance methods have access to and can mutate the state of the object it is invoked upon.</p>
<p>A message is sent from a sender to a receiver.
We commonly think of the message as having a name (i.e., the name of the method) and possibly some payload (i.e., the arguments of the method).
The receiving object may choose what to do in response to the message and may choose to provide a response to the message.</p>
<figure class="align-default" id="fig-message-passing">
<img alt="../_images/message-passing.png" src="../_images/message-passing.png" />
<figcaption>
<p><span class="caption-text">Objects can send messages to other objects as well as reply to messages sent to them.</span><a class="headerlink" href="#fig-message-passing" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Since objects encapsulate state, the messages can contain or be based upon state from the object.
In <code class="xref std std-numref docutils literal notranslate"><span class="pre">fig:message-passing</span></code> we are implying that both the name and the mood of the object on the left is part of its state.
If its state was different, its answers to the messages might be different.</p>
<p>But what about the more philosophical view of messages?
Alan Kay, a pioneer and vocal advocate of object oriented program, has argued that message passing is a more important idea than objects.</p>
<blockquote class="epigraph">
<div><p>I’m sorry that I long ago coined the term “objects” for this topic because it gets many people to focus on the lesser idea. The big idea is “messaging”.</p>
<p class="attribution">—Alan Kay <a class="reference external" href="http://lists.squeakfoundation.org/pipermail/squeak-dev/1998-October/017019.html">[source]</a></p>
</div></blockquote>
<p>Think of it this way.
The difference between message passing and simply invoking a method lies in thinking of the object that sends the message as an ambassador of information.
In 2016, Alan Kay was doing an Ask Me Anything (AMA) on <a class="reference external" href="https://news.ycombinator.com/item?id=11945722">Hacker News</a>.
When someone asked a question related to the validity of the assumptions of the object oriented paradigm, Alan Kay responded by saying:</p>
<blockquote class="epigraph">
<div><p>What if “data” is a really bad idea?</p>
<p class="attribution">—Alan Kay, in an AMA discussion on <a class="reference external" href="https://news.ycombinator.com/item?id=11945722">Hacker News</a>.</p>
</div></blockquote>
<p>This somewhat controversial statement of course sparked debate.
Rich Hickey, inventor of the programming language Closure, entered the debate to defend the opposing view.
It is truly remarkable that we get to observe as these giants discuss this fundamental topic so if your interest happens to be peaked then I highly recommend having a look at the full conversation.
At one point in the conversation Alan Kay proclaims that:</p>
<blockquote class="epigraph">
<div><p>For important negotiations we don’t send telegrams, we send ambassadors.</p>
<p class="attribution">—Alan Kay, in conversation with Rich Hickey on <a class="reference external" href="https://news.ycombinator.com/item?id=11945722">Hacker News</a>.</p>
</div></blockquote>
<p>Think about this quote.
What does it mean?
We shouldn’t send data to methods, we should send objects that we can talk to and that themselves have access to the data.
We should send an ambassador of information, not “raw” data.
A message is data as interpreted by an ambassador of that message.</p>
<p>These quotes and the heat of that debate hopefully conveys the point of how some defenders of object oriented programming truly are more philosophical than practical.
This is why I’m cautioning you that some defenders of object oriented programming are, with all due respect, quite like fundamentalists.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Whether messages and objects are good ideas or not is up for debate.
I myself happen to believe that the declarative (specifically the functional) paradigm is the future and that these philosophical discussions around message passing and objects might be a misguided distraction that doesn’t bear enough fruit.</p>
<p>In regards to the question of sending ambassadors, I suggest that you ask yourself whether multiple interpretations of the same piece of raw data perhaps is not a bug, but a useful feature?</p>
</div>
<p>But, in this book we are taking a more practical view of what object oriented programming is.
So let’s dispense with the philosophy and let’s look at it more concretely from now.</p>
<div class="dropdown note admonition">
<p class="admonition-title">Parable</p>
<p>If you happen to be familiar with the concept of “closures”, then you might enjoy this classic parable:</p>
<p><em>The venerable master Qc Na was walking with his student, Anton. Hoping to prompt the master into a discussion, Anton said “Master, I have heard that objects are a very good thing - is this true?” Qc Na looked pityingly at his student and replied, “Foolish pupil - objects are merely a poor man’s closures.”</em></p>
<p><em>Chastised, Anton took his leave from his master and returned to his cell, intent on studying closures. He carefully read the entire “Lambda: The Ultimate…” series of papers and its cousins, and implemented a small Scheme interpreter with a closure-based object system. He learned much, and looked forward to informing his master of his progress.</em></p>
<p><em>On his next walk with Qc Na, Anton attempted to impress his master by saying “Master, I have diligently studied the matter, and now understand that objects are truly a poor man’s closures.” Qc Na responded by hitting Anton with his stick, saying “When will you learn? Closures are a poor man’s object.” At that moment, Anton became enlightened.</em></p>
<p>– <a class="reference external" href="http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg03277.html">Anton van Straaten</a></p>
</div>
</section>
<section id="messages-can-contain-objects">
<h3>Messages can contain objects<a class="headerlink" href="#messages-can-contain-objects" title="Permalink to this heading">#</a></h3>
<p>Any or all of the arguments (meaning the input) as well as the response (meaning the output) might be objects.
So objects can contain objects.
We’ll talk more about this when we get to <a class="reference internal" href="object-composition.html"><span class="doc std std-doc">object composition</span></a>.
In fact, in a <em>purely</em> (here we don’t mean pure as in referentially transparent) object oriented language (such as Smalltalk) any arguments and any responses <em>must</em> be objects since all <span class="xref myst">values</span> are objects, but we’ll return to that technical detail in the <span class="xref myst">Discussion</span> section.</p>
<p>Herein lies the idea of the “interpreter” that follows with the “data” that Alan Kay talked about above.
In the non-object oriented world we pass around, let’s call it, “raw” data.
This means that everytime we want to do something with the data we have to interpret it.
In the object-oriented world however, we pass around data together with an interpreter.
The interpreter is the object and the data is contained within the object.
Now whenever we want to interact with the “raw” data somehow, we have to do so via the interpreter.</p>
</section>
<section id="impurity">
<h3>Impurity<a class="headerlink" href="#impurity" title="Permalink to this heading">#</a></h3>
<p>Since objects might be stateful we cannot guarantee that the same message always will result in the same response.
Instead, it depends on the state of the object.
The statefulness of objects mean that messages are possibly <span class="xref myst">impure</span> (in the sense of not referentially transparent).</p>
</section>
</section>
<section id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this heading">#</a></h2>
<section id="addition">
<span id="objects-examples-nat"></span><h3>Addition<a class="headerlink" href="#addition" title="Permalink to this heading">#</a></h3>
<p>Let’s talk about integer addition.
We’re going to reason by analogy, since addition is not actually implemented like this in most object oriented languages.
Nevertheless, it serves well as an example of how to convert a function to a message.</p>
<p>The addition operator (<code class="docutils literal notranslate"><span class="pre">+</span></code>) is usually thought of as a binary operator defined for numeric types such as integers.
Let’s call it <code class="docutils literal notranslate"><span class="pre">add</span></code> instead.
Remember the notation for <span class="xref myst">type signatures</span> of functions?
We might say that:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">add</span> <span class="p">:</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span>
</pre></div>
</div>
<p>We would read this signature as “<code class="docutils literal notranslate"><span class="pre">add</span></code> is a binary method that when given two <code class="docutils literal notranslate"><span class="pre">int</span></code>s, yields an <code class="docutils literal notranslate"><span class="pre">int</span></code>”.
In C# we might implement the function like this:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">add</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
<div>
    <div id='dotnet-interactive-this-cell-9842.Microsoft.DotNet.Interactive.Http.HttpPort' style='display: none'>
        The below script needs to be able to find the current output cell; this is an easy method to get it.
    </div>
    <script type='text/javascript'>
async function probeAddresses(probingAddresses) {
    function timeout(ms, promise) {
        return new Promise(function (resolve, reject) {
            setTimeout(function () {
                reject(new Error('timeout'))
            }, ms)
            promise.then(resolve, reject)
        })
    }

    if (Array.isArray(probingAddresses)) {
        for (let i = 0; i < probingAddresses.length; i++) {

            let rootUrl = probingAddresses[i];

            if (!rootUrl.endsWith('/')) {
                rootUrl = `${rootUrl}/`;
            }

            try {
                let response = await timeout(1000, fetch(`${rootUrl}discovery`, {
                    method: 'POST',
                    cache: 'no-cache',
                    mode: 'cors',
                    timeout: 1000,
                    headers: {
                        'Content-Type': 'text/plain'
                    },
                    body: probingAddresses[i]
                }));

                if (response.status == 200) {
                    return rootUrl;
                }
            }
            catch (e) { }
        }
    }
}

function loadDotnetInteractiveApi() {
    probeAddresses(["http://10.1.0.231:2048/", "http://127.0.0.1:2048/"])
        .then((root) => {
        // use probing to find host url and api resources
        // load interactive helpers and language services
        let dotnetInteractiveRequire = require.config({
        context: '9842.Microsoft.DotNet.Interactive.Http.HttpPort',
                paths:
            {
                'dotnet-interactive': `${root}resources`
                }
        }) || require;

            window.dotnetInteractiveRequire = dotnetInteractiveRequire;

            window.configureRequireFromExtension = function(extensionName, extensionCacheBuster) {
                let paths = {};
                paths[extensionName] = `${root}extensions/${extensionName}/resources/`;
                
                let internalRequire = require.config({
                    context: extensionCacheBuster,
                    paths: paths,
                    urlArgs: `cacheBuster=${extensionCacheBuster}`
                    }) || require;

                return internalRequire
            };
        
            dotnetInteractiveRequire([
                    'dotnet-interactive/dotnet-interactive'
                ],
                function (dotnet) {
                    dotnet.init(window);
                },
                function (error) {
                    console.log(error);
                }
            );
        })
        .catch(error => {console.log(error);});
    }

// ensure `require` is available globally
if ((typeof(require) !==  typeof(Function)) || (typeof(require.config) !== typeof(Function))) {
    let require_script = document.createElement('script');
    require_script.setAttribute('src', 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js');
    require_script.setAttribute('type', 'text/javascript');
    
    
    require_script.onload = function() {
        loadDotnetInteractiveApi();
    };

    document.getElementsByTagName('head')[0].appendChild(require_script);
}
else {
    loadDotnetInteractiveApi();
}

    </script>
</div></div></div>
</div>
<p>However, in the object oriented world, addition is not a binary function that can be invoked by passing two integers.
In the object oriented world, <code class="docutils literal notranslate"><span class="pre">add</span></code> is a message that we send to an object of type <code class="docutils literal notranslate"><span class="pre">int</span></code> while also giving another <code class="docutils literal notranslate"><span class="pre">int</span></code> as an argument.
So while the function <code class="docutils literal notranslate"><span class="pre">add</span></code> is binary, the message <code class="docutils literal notranslate"><span class="pre">add</span></code> is unary.</p>
<p>As we’ve already learned, <code class="docutils literal notranslate"><span class="pre">int</span></code> is, in C#, a <span class="xref myst">simple type</span> which means that it’s a built-in <a class="reference internal" href="../chapters/value-and-reference-semantics.html#value-and-reference-semantics"><span class="std std-ref">value type</span></a>.
So, let’s instead invent our own type called <code class="docutils literal notranslate"><span class="pre">Nat</span></code> when talking about objects and messages.</p>
<p>So, we’ll rewrite the type signature of our object oriented version of addition as:</p>
<p id="type-signatures-oo">Type signatures for object oriented <a class="reference internal" href="instance-methods.html"><span class="doc std std-doc">instance methods</span></a> which is what messages are written in different ways depending on who you ask, but I prefer to use the squiggly arrow (<code class="docutils literal notranslate"><span class="pre">~&gt;</span></code>).
I would write the type signature of an object oriented add method like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Add</span> <span class="p">:</span> <span class="n">Nat</span> <span class="o">~&gt;</span> <span class="n">Nat</span> <span class="o">-&gt;</span> <span class="n">Nat</span>
</pre></div>
</div>
<p>We would read this signature as “<code class="docutils literal notranslate"><span class="pre">Add</span></code> is an instance method, defined on the type <code class="docutils literal notranslate"><span class="pre">Nat</span></code>, which takes a <code class="docutils literal notranslate"><span class="pre">Nat</span></code> and returns a <code class="docutils literal notranslate"><span class="pre">Nat</span></code>”.
Notice how we’re using two different types of arrows in the example above.
The first arrow, the squiggly arrow (<code class="docutils literal notranslate"><span class="pre">~&gt;</span></code>), denotes that whatever follows on the right is not a function, but an instance method defined on the type <code class="docutils literal notranslate"><span class="pre">Nat</span></code>.
The second arrow (<code class="docutils literal notranslate"><span class="pre">-&gt;</span></code>) is our usual arrow which in this case says that the instance method maps from <code class="docutils literal notranslate"><span class="pre">Nat</span></code> to <code class="docutils literal notranslate"><span class="pre">Nat</span></code>.</p>
<p>We haven’t talked about enough syntax yet to understand an implementation of this instance method but let me just show you what it could look like:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Nat</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// This is known as an instance field.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// This is known as a constructor.</span>
<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="nf">Nat</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="w">    </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// This is the instance method add.</span>
<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="n">Nat</span><span class="w"> </span><span class="nf">Add</span><span class="w"> </span><span class="p">(</span><span class="n">Nat</span><span class="w"> </span><span class="n">other</span><span class="p">)</span>
<span class="w">    </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Nat</span><span class="w"> </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">n</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// This is just a helper method to get the</span>
<span class="w">  </span><span class="c1">// contained number out so that we can print it.</span>
<span class="w">  </span><span class="c1">// We will learn more about this later.</span>
<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="nf">ToString</span><span class="p">()</span>
<span class="w">    </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">n</span><span class="p">.</span><span class="n">ToString</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<p>We would be able to use the type to create objects of type <code class="docutils literal notranslate"><span class="pre">Nat</span></code> and then add them like this:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">Nat</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Nat</span><span class="p">(</span><span class="m">10</span><span class="p">);</span><span class="w"> </span><span class="c1">// Instantiates an object of type Nat.</span>
<span class="n">Nat</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Nat</span><span class="p">(</span><span class="m">2</span><span class="p">);</span><span class="w">  </span><span class="c1">// Instantiates an object of type Nat.</span>

<span class="c1">// Sends the message (calls the instance method) Add</span>
<span class="c1">// to the object x, passing object y as an argument.</span>
<span class="n">Nat</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>

<span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">$&quot;{x} + {y} = {z}&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>10 + 2 = 12
</pre></div>
</div>
</div>
</div>
<p>Don’t worry if this feels like an overwhelming amount of code.
I just wanted to show you a quick example of what the implementation would look like when following the object oriented way.
We’ll talk much more about <span class="xref myst">classes</span>, <a class="reference internal" href="instance-methods.html"><span class="doc std std-doc">instance methods</span></a>, <a class="reference internal" href="fields.html"><span class="doc std std-doc">fields</span></a> and more in the coming chapter.</p>
</section>
<section id="coordinates">
<h3>Coordinates<a class="headerlink" href="#coordinates" title="Permalink to this heading">#</a></h3>
<p>Before we leave, let’s quickly discuss the example I gave earlier of moving around players in a game on a two dimensional grid.
Each player probably has at least two values associated with it at any given point in time: An <code class="docutils literal notranslate"><span class="pre">x</span></code> and a <code class="docutils literal notranslate"><span class="pre">y</span></code> coordinate.
Let’s model these as integers.</p>
<p>Solving this in a procedural style we might declare four variables that correspond to the <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> coordinates of both players.
We would then define a bunch of methods for moving both players in a number of different directions like north, east, south, and west.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Player1</span>
<span class="kt">int</span><span class="w"> </span><span class="n">player1X</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">player1Y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>

<span class="c1">// Player 2</span>
<span class="kt">int</span><span class="w"> </span><span class="n">player2X</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">player2Y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>

<span class="c1">// Player 1 move commands</span>
<span class="k">void</span><span class="w"> </span><span class="nf">MovePlayer1East</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">player1X</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span>
<span class="k">void</span><span class="w"> </span><span class="nf">MovePlayer1West</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">player1X</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span>
<span class="k">void</span><span class="w"> </span><span class="nf">MovePlayer1North</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">player1Y</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span>
<span class="k">void</span><span class="w"> </span><span class="nf">MovePlayer1South</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">player1Y</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span>


<span class="c1">// Player 2 move commands</span>
<span class="k">void</span><span class="w"> </span><span class="nf">MovePlayer2East</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">player2X</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span>
<span class="k">void</span><span class="w"> </span><span class="nf">MovePlayer2West</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">player2X</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span>
<span class="k">void</span><span class="w"> </span><span class="nf">MovePlayer2North</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">player2Y</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span>
<span class="k">void</span><span class="w"> </span><span class="nf">MovePlayer2South</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">player2Y</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span>
</pre></div>
</div>
</div>
</div>
<p>This solution is of course both cumbersome to maintain and very prone to error.
We’ve duplicated the business logic of what it means to move north, east, south, since we need to define it for both players.
Remember the DRY (<span class="xref myst">Don’t repeat yourself</span>) principle?</p>
<p>We’ve also hard-coded the number of players to two.
What if we have hundreds methods that operate on players and then suddenly we realize that we want to add another player?</p>
<p>There are of course many ways of addressing these concerns while still solving the problem in a procedural style.
One way would be to stick all the player positions in arrays where the indices determine which player we are talking about.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">[]</span><span class="w"> </span><span class="n">xPositions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">[</span><span class="m">2</span><span class="p">];</span>
<span class="kt">int</span><span class="p">[]</span><span class="w"> </span><span class="n">yPositions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">[</span><span class="m">2</span><span class="p">];</span>

<span class="k">void</span><span class="w"> </span><span class="nf">MovePlayerEast</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">player</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">xPositions</span><span class="p">[</span><span class="n">player</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span>
<span class="k">void</span><span class="w"> </span><span class="nf">MovePlayerWest</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">player</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">xPositions</span><span class="p">[</span><span class="n">player</span><span class="p">]</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span>
<span class="k">void</span><span class="w"> </span><span class="nf">MovePlayerNorth</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">player</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">yPositions</span><span class="p">[</span><span class="n">player</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span>
<span class="k">void</span><span class="w"> </span><span class="nf">MovePlayerSouth</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">player</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">yPositions</span><span class="p">[</span><span class="n">player</span><span class="p">]</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span>
</pre></div>
</div>
</div>
</div>
<p>While this solves the problem we loose static type safety for player access.
We expose ourselves to potential run-time errors.
What happens if we mistakenly pass the number <code class="docutils literal notranslate"><span class="pre">1</span></code> to a move method, as in <code class="docutils literal notranslate"><span class="pre">MovePlayerEast(1)</span></code> when we only happen to have a single player in the game.
That’s right, instead of getting an error at compile time, we get an <code class="docutils literal notranslate"><span class="pre">IndexOutOfRangeException</span></code> when actually running the program.
Remember the principle of <a class="reference internal" href="../chapters/fail-fast.html#fail-fast"><span class="std std-ref">failling fast</span></a>?
We should prefer compile-time errors over run-time errors.</p>
<p>Hopefully you are starting to see that what we need here is something a bit more powerful than procedures.
We need more powerful <a class="reference internal" href="../chapters/data-structures.html#data-structures"><span class="std std-ref">data structures</span></a>.
We need a better abstraction of what we’re trying to model.</p>
<p>C# does however not allow us to construct custom data structures that aren’t also essentially objects (or implicitly <a class="reference internal" href="#everything-is-an-object"><span class="std std-ref">convertible to an object</span></a>).
So for the sake of not having to introduce an entirely new language into this book we’re going to pretend that languages that existed before the advent of object oriented programming didn’t grant us encapsulated custom data structures.
That assumption is certainly <em>not true</em>.
Non-object oriented languages did indeed provide mechanisms for encapsulation and as such it would be possible to solve the issues outlined even in a language that we might want to categorize as procedural.</p>
<p>But, let’s get back to object oriented programming.
We’ll talk about <span class="xref myst">classes</span> very soon but allow me to give you a quick taste of what an object oriented solution might look like.
If we were to model players in a class based object oriented language then that class might have a <a class="reference internal" href="constructors.html"><span class="doc std std-doc">constructor</span></a> that takes two arguments, and have two instance <a class="reference internal" href="fields.html"><span class="doc std std-doc">fields</span></a> (also known as “instance variables”).
These two arguments and instance fields are used to encapsulate the <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> coordinates.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Player</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>

<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="nf">Player</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">initialX</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">initialY</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">initialX</span><span class="p">;</span>
<span class="w">    </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">initialY</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">MoveEast</span><span class="w"> </span><span class="p">()</span><span class="w">  </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span>
<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">MoveWest</span><span class="w"> </span><span class="p">()</span><span class="w">  </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span>
<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">MoveNorth</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span>
<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">MoveSouth</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span>

<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="nf">ToString</span><span class="p">()</span>
<span class="w">    </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">$&quot;({x} , {y})&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<p>We would interact with the player class by sending move messages to the player.
Given this class, we could then instantiate a bunch of player objects:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">Player</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Player</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">);</span>
<span class="n">Player</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Player</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<p>We are then ready to send messages to these player objects to invite them to move in different directions.
Meaning, we are ready to call instance methods on them.
Which means that we can invite the objects to change their internal states.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">p1</span><span class="p">.</span><span class="n">MoveEast</span><span class="p">();</span>
<span class="n">p1</span><span class="p">.</span><span class="n">MoveEast</span><span class="p">();</span>
<span class="n">p1</span><span class="p">.</span><span class="n">MoveSouth</span><span class="p">();</span>

<span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">p1</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(2 , -1)
</pre></div>
</div>
</div>
</div>
<p>Now, we can’t try to access a non-existent player but we can still create an arbitrary number of players.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">p2</span><span class="p">.</span><span class="n">MoveWest</span><span class="p">();</span>
<span class="n">p2</span><span class="p">.</span><span class="n">MoveSouth</span><span class="p">();</span>
<span class="n">p2</span><span class="p">.</span><span class="n">MoveSouth</span><span class="p">();</span>

<span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(-1 , -2)
</pre></div>
</div>
</div>
</div>
<p>What do we gain from this?
Well, without getting into <a class="reference internal" href="subtype-polymorphism.html"><span class="doc std std-doc">subtype polymorphism</span></a> we gain encapsulation.
It’s arguably harder to accidentally update the position of one player when we actually were intending to update the position of the other.
We’re also able to trivially support an arbitrary number of players without having to write any more code and without risking run-time caused by for example trying to access indexes in arrays that don’t exist.</p>
<p>Remember, the point is not that this cannot be done in a procedural language.
It can.
Any Turing complete language can solve any computable problem.
That’s not the problem.
Heck, we could write all programs in <a class="reference internal" href="../chapters/old-compilation.html#machine-code"><span class="std std-ref">machine code</span></a> if we wanted to.</p>
<p>But if the problem isn’t that it cannot be done, then what is the problem?
The problem is <a class="reference internal" href="maintainability.html"><span class="doc std std-doc">maintainability</span></a>.
Remember?
Writing software that will put us and keep us in business.
Writing software that will keep us ahead of our competition.</p>
</section>
</section>
<section id="discussion">
<h2>Discussion<a class="headerlink" href="#discussion" title="Permalink to this heading">#</a></h2>
<span class="target" id="everything-is-an-object"></span><p>When trying to learn more about object oriented programming you may have come across the following phrase:</p>
<blockquote class="epigraph">
<div><p>Everything is an object.</p>
</div></blockquote>
<p>This is what we referred to when we, earlier in this chapter, called some object oriented languages “pure”.</p>
<p>When saying that a language such as Smalltalk is a “purely” object oriented language we don’t mean pure in the sense of <span class="xref myst">referential transparency</span>.
We mean “pure” in the sense that, in the language, everything (or almost everything) is an object.</p>
<p>We tend to use the word “everything” when talking about how purely object oriented a language is.
However, it would be more accurate to say something like “all values that you can construct and reference using variables”.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>What I’m about to say now is mostly for the sake of completeness.
If you feel like this is wooshing over your head, make a note of this section, and come back to it when you’ve got more tools in your belt.</p>
</div>
<p>We haven’t yet talked about <a class="reference internal" href="inheritance.html"><span class="doc std std-doc">inheritance</span></a> and <a class="reference internal" href="interfaces.html"><span class="doc std std-doc">interfaces</span></a> but another way of saying this is that “all types derive from <code class="docutils literal notranslate"><span class="pre">Object</span></code>”.
However, this is also only almost true in C#.
C# is not a purely object object oriented language in the sense that all types derive from <code class="docutils literal notranslate"><span class="pre">Object</span></code>.</p>
<p>When discussing <span class="xref myst">paradigms</span> we established that C#, like many other contemporary programming languages, is a multi-paradigm language.
C# contains ideas from procedural, object oriented, as well as functional programming.</p>
<p>In Java, one problem is, the types that in C# are called built-in value types, or <a class="reference internal" href="../chapters/simple-types.html#simple-types"><span class="std std-ref">simple types</span></a>.
In Java these are known as primitive types and they are not objects, but in C# they actually are.
So if simple types are objects, then these are not the problem.</p>
<p>What are the non-object types in C#?
The non-object types in C# are:</p>
<ol class="arabic simple">
<li><p>Pointers</p></li>
<li><p>Interfaces</p></li>
<li><p>Open type parameters</p></li>
</ol>
<p>You could argue that pointers are an archaic remnant of the procedural days.
As such, we won’t talk about them here.</p>
<p>Interfaces however are key to object oriented programming since they (as well as inheritance) enable what is known as <a class="reference internal" href="subtype-polymorphism.html"><span class="doc std std-doc">subtype polymorphism</span></a>.
We’ll talk much more about this later.
Suffice to say however that while interfaces themselves are not objects, any object that implements an interface must (tautologically) be an object because only objects can implement interfaces.</p>
<p>The same line of reasoning follows with open type parameters.
Any open type parameter will eventually be replaced by a concrete type that is an object.
Open type parameters will be discussed in much more detail when we talk about <a class="reference internal" href="generics.html"><span class="doc std std-doc">generic programming</span></a>.</p>
<p>So, it would be more correct to follow the assertion of Eric Lippert who states that:
“Every non-pointer type is <em>convertible</em> to object.”</p>
<blockquote class="epigraph">
<div><p>“Every non-pointer type is <em>convertible</em> to object.”</p>
<p class="attribution">—<a class="reference external" href="https://docs.microsoft.com/en-gb/archive/blogs/ericlippert/not-everything-derives-from-object">Eric Lippert</a></p>
</div></blockquote>
<p>We should however also mention that while an object of a child type can be implicitly converted to its parent class, when value types, such as the simple types like <code class="docutils literal notranslate"><span class="pre">int</span></code>, are converted to objects this causes what is known as <a class="reference internal" href="../chapters/boxing.html#boxing"><span class="std std-ref">boxing</span></a>.
More on that later though.</p>
</section>
<section id="exercises">
<h2>Exercises<a class="headerlink" href="#exercises" title="Permalink to this heading">#</a></h2>
<div class="exercise admonition" id="old/objects-old-exercise-0">

<p class="admonition-title"></p>
<section id="exercise-content">
<p>What does it mean that an object is <em>stateful</em>?</p>
</section>
</div>
<div class="exercise admonition" id="old/objects-old-exercise-1">

<p class="admonition-title"></p>
<section id="exercise-content">
<p>What is <em>message passing</em>?</p>
</section>
</div>
<div class="exercise admonition" id="old/objects-old-exercise-2">

<p class="admonition-title"></p>
<section id="exercise-content">
<p>What is <em>encapsulation</em>?</p>
</section>
</div>
<div class="exercise admonition" id="old/objects-old-exercise-3">

<p class="admonition-title"></p>
<section id="exercise-content">
<p>What is <em>information hiding</em>?</p>
</section>
</div>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: ".net-csharp"
        },
        kernelOptions: {
            name: ".net-csharp",
            path: "./old"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = '.net-csharp'</script>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; All rights reserved. By using this site, you agree to our use of cookies for Google Analytics.
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Objects (old)</a><ul>
<li><a class="reference internal" href="#motivation">Motivation</a></li>
<li><a class="reference internal" href="#definition">Definition</a><ul>
<li><a class="reference internal" href="#information-hiding">Encapsulation</a></li>
<li><a class="reference internal" href="#message-passing">Message passing</a></li>
<li><a class="reference internal" href="#messages-can-contain-objects">Messages can contain objects</a></li>
<li><a class="reference internal" href="#impurity">Impurity</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples">Examples</a><ul>
<li><a class="reference internal" href="#addition">Addition</a></li>
<li><a class="reference internal" href="#coordinates">Coordinates</a></li>
</ul>
</li>
<li><a class="reference internal" href="#discussion">Discussion</a></li>
<li><a class="reference internal" href="#exercises">Exercises</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script src="https://www.googletagmanager.com/gtag/js?id=G-V69WNXD095"></script>
    <script src="../_static/analytics.js"></script>
    <script src="../_static/custom.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js"></script>
    <script src="../_static/scripts/furo.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    </body>
</html>