<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />
<link rel="index" title="Index" href="../genindex.html" /><link rel="search" title="Search" href="../search.html" />

    <!-- Generated with Sphinx 5.0.2 and Furo 2023.03.27 -->
        <title>Nothingness - The Object Oriented Way</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?digest=fad236701ea90a88636c2a8c73b44ae642ed2a53" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/exercise.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    <link rel="stylesheet" type="text/css" href="../_static/style.css" />
    
    


<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">The Object Oriented Way</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand centered" href="../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo" src="../_static/logo.png" alt="Logo"/>
  </div>
  
  <span class="sidebar-brand-text">The Object Oriented Way</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Chapters</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../chapters/syntax.html">1. Syntax</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/hello-world.html">2. Hello world</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/compilation.html">3. Compilation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/execution.html">4. Execution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/interpretation.html">5. Interpretation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/comments.html">6. Comments</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/values.html">7. Values</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/variables.html">8. Variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/data-types.html">9. Data types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/expressions.html">10. Expressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/arithmetic-operators.html">11. Arithmetic operators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/equality-operators.html">12. Equality operators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/relational-operators.html">13. Relational operators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/logical-operators.html">14. Logical operators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/assignment-operator.html">15. Assignment operator</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/precedence.html">16. Precedence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/associativity.html">17. Associativity</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/constants.html">18. Constants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/statements.html">19. Statements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/type-inference.html">20. Type inference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/type-checking.html">21. Type checking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/floating-point-types.html">22. Floating-point types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/enumeration-types.html">23. Enumeration types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/selection-statements.html">24. Selection statements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/selection-expressions.html">25. Selection expressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/iteration.html">26. Iteration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/arrays.html">27. Arrays</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/reference-types.html">28. Reference types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/value-types.html">29. Value types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/local-functions.html">30. Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/fat-arrows.html">31. Fat arrows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/recursion.html">32. Recursion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/namespaces.html">33. Namespaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/objects.html">34. Objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/classes.html">35. Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/access-modifiers.html">36. Access modifiers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/fields.html">37. Fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/constructors.html">38. Constructors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/the-this-keyword.html">39. The <code class="docutils literal notranslate"><span class="pre">this</span></code> keyword</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/instance-methods.html">40. Instance methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/encapsulation.html">41. Encapsulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/auto-implemented-properties.html">42. Auto-implemented properties</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/manually-implemented-properties.html">43. Manually implemented properties</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/object-initializers.html">44. Object initializers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/read-only-fields.html">45. Read-only fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/read-only-properties.html">46. Read-only properties</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/computed-properties.html">47. Computed properties</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/required-properties-and-fields.html">48. Required properties and fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/init-only-properties.html">49. Init-only properties</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/instance-method-overloading.html">50. Instance method overloading</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/constructor-overloading.html">51. Constructor overloading</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/static-fields.html">52. Static fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/static-constructors.html">53. Static constructors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/static-methods.html">54. Static methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/static-properties.html">55. Static properties</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/static-classes.html">56. Static classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/top-level-statements.html">57. Top-level statements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/object-composition.html">58. Object composition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/interfaces.html">59. Interfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/subtype-polymorphism.html">60. Subtype polymorphism</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/run-time-type-vs-compile-time-type.html">61. Run-time type vs compile-time type</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/dynamic-dispatch.html">62. Dynamic dispatch</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/multiple-interfaces.html">63. Multiple interfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/default-interface-methods.html">64. Default interface methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/inheritance.html">65. Inheritance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/overriding.html">66. Overriding</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/hiding.html">67. Hiding</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/the-base-keyword.html">68. The <code class="docutils literal notranslate"><span class="pre">base</span></code> keyword</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/constructor-chaining.html">69. Constructor chaining</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/protected.html">70. Protected access modifier</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/abstract-classes.html">71. Abstract classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/interface-inheritance.html">72. Interface inheritance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/type-conversions.html">73. Type conversions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/upcasting.html">74. Upcasting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/downcasting.html">75. Downcasting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/everything-is-an-object.html">76. Everything is an object</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/uml-class-diagrams.html">77. UML class diagrams</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/maintainability.html">78. Maintainability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/refactoring.html">79. Refactoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/generics.html">80. Generics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/generic-types.html">81. Generic types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/generics-and-type-errors.html">82. Generics and type errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/generic-supertypes.html">83. Generic supertypes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/generic-methods.html">84. Generic methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/type-parameter-constraints.html">85. Type parameter constraints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/collections.html">86. Collections</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/collection-initializers.html">87. Collection initializers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/replace-conditional-with-polymorphism.html">88. Replace conditional with polymorphism</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/dependency-injection.html">89. Dependency injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/composition-over-inheritance.html">90. Composition over inheritance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/strategy-pattern.html">91. Strategy pattern</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/bridge-pattern.html">92. Bridge pattern</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/delegates.html">93. Delegates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/generic-delegates.html">94. Generic delegates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/built-in-delegates.html">95. Built-in delegates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/multicast-delegates.html">96. Multicast delegates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/lambdas.html">97. Lambdas</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/observer-pattern.html">98. Observer pattern</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/events.html">99. Events</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/event-conventions.html">100. Event conventions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/event-driven-programming.html">101. Event-driven programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/iterator-pattern.html">102. Iterator pattern</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/enumerables.html">103. Enumerables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/the-yield-statement.html">104. The <code class="docutils literal notranslate"><span class="pre">yield</span></code> statement</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/anonymous-types.html">105. Anonymous types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/linq.html">106. LINQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/variance.html">107. Variance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/covariance.html">108. Covariance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/contravariance.html">109. Contravariance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/invariance.html">110. Invariance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/liskov-substitution-principle.html">111. Liskov substitution principle</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/variant-classes.html">112. Variant classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/variant-delegates.html">113. Variant delegates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/variant-generic-delegates.html">114. Variant generic delegates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/variant-generic-interfaces.html">115. Variant generic interfaces</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Labs (part 1)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../labs/fields.html">Lab: Fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/instance-methods.html">Lab: Instance methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/encapsulation.html">Lab: Encapsulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/instance-method-overloading.html">Lab: Instance Method Overloading</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/constructor-overloading.html">Lab: Constructor overloading</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/manually-implemented-properties.html">Lab: Manually implemented properties</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/computed-properties.html">Lab: Computed Properties</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/static.html">Lab: Static</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/object-composition.html">Lab: Object composition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/interfaces.html">Lab: Interfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/subtype-polymorphism.html">Lab: Subtype polymorphism</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/overriding.html">Lab: Overriding</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/default-interface-methods.html">Lab: Default Interface Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/the-base-keyword.html">Lab: The <code class="docutils literal notranslate"><span class="pre">base</span></code> keyword</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/constructor-chaining.html">Lab: Constructor Chaining</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/protected.html">Lab: <code class="docutils literal notranslate"><span class="pre">protected</span></code> access modifier</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/replace-conditional-with-polymorphism.html">Lab: Replace conditional with polymorphism</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Labs (part 2)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../labs/generics.html">Lab: Generics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/generic-types.html">Lab: Generic types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/generic-supertypes.html">Lab: Generic Supertypes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/type-parameter-constraints.html">Lab: Type parameter constraints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/composition-over-inheritance.html">Lab: Composition over Inheritance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/bridge-pattern.html">Lab: Bridge Pattern</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/delegates.html">Lab: Delegates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/lambdas.html">Lab: Lambdas</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/observer-pattern.html">Lab: Observer Pattern</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/events.html">Lab: Events</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/iterator-pattern.html">Lab: Iterator pattern</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/enumerables.html">Lab: Enumerables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/the-yield-keyword.html">Lab: The <code class="docutils literal notranslate"><span class="pre">yield</span></code> keyword</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/variant-classes.html">Lab: Variant classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/variant-delegates.html">Lab: Variant delegates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/variant-generic-delegates.html">Lab: Variant Generic Delegates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/variant-generic-interfaces.html">Lab: Variant Generic Interfaces</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section class="tex2jax_ignore mathjax_ignore" id="nothingness">
<h1>Nothingness<a class="headerlink" href="#nothingness" title="Permalink to this heading">#</a></h1>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Work in progress.</p>
</div>
<p>In imperative programming languages we usually find two kinds of nothingness: <code class="docutils literal notranslate"><span class="pre">null</span></code> and <code class="docutils literal notranslate"><span class="pre">void</span></code>.
The former, <code class="docutils literal notranslate"><span class="pre">null</span></code>, is a value that represents the absence of a value in a variable.
The latter, <code class="docutils literal notranslate"><span class="pre">void</span></code>, is a type that represents the absence of a value returned from an operation.
<code class="docutils literal notranslate"><span class="pre">null</span></code> is an actual value that belongs to many types and that you can hold in a variable.
But <code class="docutils literal notranslate"><span class="pre">void</span></code> is a type of which there are no values.</p>
<p>In this chapter we’re mostly going to talk about <code class="docutils literal notranslate"><span class="pre">null</span></code> and how its treated in C#.
We will briefly discuss <code class="docutils literal notranslate"><span class="pre">void</span></code> but it will be dealt with more appropriately when we get to <a class="reference internal" href="static-methods.html"><span class="doc std std-doc">methods</span></a>.</p>
<section id="nullable-value-types">
<h2>Nullable value types<a class="headerlink" href="#nullable-value-types" title="Permalink to this heading">#</a></h2>
<p>In the chapter on <span class="xref myst">data types</span> we modeled the type <code class="docutils literal notranslate"><span class="pre">int</span></code> as a mathematical set.
The set did however not involve the value <code class="docutils literal notranslate"><span class="pre">null</span></code>.
Why?</p>
<p>The type <code class="docutils literal notranslate"><span class="pre">int</span></code> is what is known as a <a class="reference internal" href="../chapters/value-and-reference-semantics.html#value-and-reference-semantics"><span class="std std-ref">value type</span></a> and value types are, in C#, not “nullable”.
Being “nullable” means that the set that models the type also contains <code class="docutils literal notranslate"><span class="pre">null</span></code>.
If a type is “non-nullable” then the set doesn’t contain <code class="docutils literal notranslate"><span class="pre">null</span></code>.</p>
<p>We can verify that <code class="docutils literal notranslate"><span class="pre">int</span></code> is not nullable by trying to compile a program that assigns the value <code class="docutils literal notranslate"><span class="pre">null</span></code> to an <code class="docutils literal notranslate"><span class="pre">int</span></code>.
If we do, then we get a compiler error.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">null</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-output notranslate"><div class="highlight"><pre><span></span><span class="go">error CS0037: Cannot convert null to &#39;int&#39; because it is a nonnullable value type.</span>
</pre></div>
</div>
<p>The error message above states that the value <code class="docutils literal notranslate"><span class="pre">null</span></code> cannot be converted into an <code class="docutils literal notranslate"><span class="pre">int</span></code> since the type <code class="docutils literal notranslate"><span class="pre">int</span></code> is non-nullable.
This means that <code class="docutils literal notranslate"><span class="pre">null</span></code> isn’t a member of the set <code class="docutils literal notranslate"><span class="pre">int</span></code> and that there is no implicit conversion from <code class="docutils literal notranslate"><span class="pre">null</span></code> to <code class="docutils literal notranslate"><span class="pre">int</span></code>.
Of course there couldn’t possibly exist a general-case conversion from <code class="docutils literal notranslate"><span class="pre">null</span></code> to <code class="docutils literal notranslate"><span class="pre">int</span></code> because which integer could we possibly choose to represent the absence of an integer.
Zero? One? Negative one?
It all depends on context, so it is sensible that C# does not give us a general conversion from <code class="docutils literal notranslate"><span class="pre">null</span></code> to <code class="docutils literal notranslate"><span class="pre">int</span></code>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>As an aside you might be interested to know that some methods, such as <code class="docutils literal notranslate"><span class="pre">String.IndexOf</span></code>, do in fact return values that they assign special meaning to, such as negative one (<code class="docutils literal notranslate"><span class="pre">-1</span></code>), to denote the failure of an operation or the absence of a value to return.
See <a class="reference external" href="https://docs.microsoft.com/en-us/dotnet/api/system.string.indexof?view=net-6.0">the documentation</a> for more information on the IndexOf method for example.</p>
</div>
<p>However, it is possible to create a nullable value type from a non-nullable value type by appending a question mark to the type name.
This means that we are changing the type, not the value.</p>
<p>So if we say <code class="docutils literal notranslate"><span class="pre">int?</span></code> instead of <code class="docutils literal notranslate"><span class="pre">int</span></code> then we are dealing with a nullable value type.
Appending a question mark works to create a nullable type works for all value types.</p>
<p>So the set <span class="math notranslate nohighlight">\(\mathit{int?}\)</span> is the union of the set <span class="math notranslate nohighlight">\(\mathit{int}\)</span> and the <code class="docutils literal notranslate"><span class="pre">null</span></code> type which is a singleton set whose only element is <span class="math notranslate nohighlight">\(\mathit{null}\)</span>.</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[
\mathit{int?} = \mathit{int} \cup \{ \mathit{null} \}
\]</div>
</div>
<p>The set <span class="math notranslate nohighlight">\(\mathit{int?}\)</span> corresponds to the data type <code class="docutils literal notranslate"><span class="pre">int?</span></code> and we can now actually compile a program that assigns <code class="docutils literal notranslate"><span class="pre">null</span></code> to a variable of this type.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">int?</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">null</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-output notranslate"><div class="highlight"><pre><span></span><span class="go">Build succeeded.</span>
</pre></div>
</div>
<p>Whether this is a sensible idea or not is a different question.
In the chapter on <span class="xref myst">Values</span> we already alluded to some of the difficulties arising from the usage of <code class="docutils literal notranslate"><span class="pre">null</span></code>.
For now though, it is useful to keep exploring the concept of <code class="docutils literal notranslate"><span class="pre">null</span></code> as we are learning about how data types work.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Being non-nullable is not the only property of value types.
Unless implemented otherwise, value types also have, what’s known as, “value semantics” rather than “reference semantics”.
But more on this in the chapter on <a class="reference internal" href="../chapters/value-and-reference-semantics.html#value-and-reference-semantics"><span class="std std-ref">value and reference semantics</span></a>.</p>
</div>
<p>Broadly speaking, there are two categories of types in C#: value types and reference types.
We’ll talk more about what these base types are in the chapter on <a class="reference internal" href="../chapters/value-and-reference-semantics.html#value-and-reference-semantics"><span class="std std-ref">value and reference type semantics</span></a>.
For now, we should however mention that prior to <a class="reference external" href="https://docs.microsoft.com/en-us/dotnet/csharp/nullable-references">C# 8.0</a>, all reference types were nullable.</p>
<p>We should also mention that when you do object oriented programming, our main building block is the object.
And since objects are reference types, this used to mean that most of our custom types were nullable.
If null is a billion dollar mistake, reference types are nullable, we use mostly reference types, and objects are reference types, then most of our code is subject to this billoion dollar mistake.
Not ideal.</p>
</section>
<section id="nullable-reference-types">
<span id="id1"></span><h2>Nullable reference types<a class="headerlink" href="#nullable-reference-types" title="Permalink to this heading">#</a></h2>
<p>Fortunately, C# now has a setting called “nullable reference types” which is enabled by default in new projects since <a class="reference external" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/nullable-reference-types">.NET 6 (C# 10)</a>.
You can find the setting in your <code class="docutils literal notranslate"><span class="pre">.csproj</span></code> file and it looks like this:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;Nullable&gt;</span>enable<span class="nt">&lt;/Nullable&gt;</span>
</pre></div>
</div>
<p>The short story is that, with this setting turned on, reference types are no longer nullable.
However, if you try to assign the literal <code class="docutils literal notranslate"><span class="pre">null</span></code> to a variable that’s of a reference type you don’t actually get a type error but simply a compiler warning.
This warning is emitted from a static code analysis procedure known as null state analysis.</p>
<p>Take the reference type <code class="docutils literal notranslate"><span class="pre">string</span></code> for example.
Let’s say we declare a variable of type <code class="docutils literal notranslate"><span class="pre">string</span></code> and initialize it to the value <code class="docutils literal notranslate"><span class="pre">null</span></code>.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">string</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">null</span><span class="p">;</span>
</pre></div>
</div>
<p>If we have the setting for nullable reference types turned on, then we get the following warning upon compilation:</p>
<div class="highlight-output notranslate"><div class="highlight"><pre><span></span><span class="go">warning CS8600: Converting null literal or possible null value to non-nullable type.</span>
</pre></div>
</div>
<p>Notice how the error message is referring to the variable of type <code class="docutils literal notranslate"><span class="pre">string</span></code> as being non-nullable.
The error message is structured exactly like a type error.
If, for example, we tried to assign a value of type <code class="docutils literal notranslate"><span class="pre">int</span></code> to a variable of type <code class="docutils literal notranslate"><span class="pre">string</span></code> we would get an error message with the same structure:</p>
<div class="highlight-output notranslate"><div class="highlight"><pre><span></span><span class="go">error CS0029: Cannot implicitly convert type &#39;int&#39; to &#39;string&#39;.</span>
</pre></div>
</div>
<p>Yet, in the case where we assign a null literal to a value of the non-nullable reference type string this is not a type error in the classic sense.
For one, it’s a warning and not an error.
But also, this is a warning that’s emitted upon null state analysis and not by type checking.
As we shall see soon, null state analysis is a much more complicated procedure than type-checking.
In <span class="xref myst">type-checking</span> we simply check whether the type of a value is the same as, or is <span class="xref myst">implicitly convertible</span> to, a value of the expected type.
If <code class="docutils literal notranslate"><span class="pre">null</span></code> is a legal value of the expected type, or if it is possible to implicitly convertible to a value of the expected type then the program simply type-checks.
In null state analysis however, we look at the actual flow of the program in attempts to verify whether a value might ever contain the value <code class="docutils literal notranslate"><span class="pre">null</span></code>.
If the compiler cannot guarantee that <code class="docutils literal notranslate"><span class="pre">null</span></code> is not ever used where a certain reference type is expected it will emit a warning upon compilation.</p>
<p>So it isn’t entirely honest to call <code class="docutils literal notranslate"><span class="pre">string</span></code> non-nullable since we are still able to compile and run programs that uses <code class="docutils literal notranslate"><span class="pre">null</span></code> where values of type <code class="docutils literal notranslate"><span class="pre">string</span></code> are expected.
It’s not that <code class="docutils literal notranslate"><span class="pre">null</span></code> isn’t a valid member of the set underlying each reference type or that there no longer exists an implicit conversion from <code class="docutils literal notranslate"><span class="pre">null</span></code> to the type in question.
It’s that whenever you try to assign <code class="docutils literal notranslate"><span class="pre">null</span></code> to a non-nullable reference type you simply get a compiler warning.
You can still compile the program and it might run just fine.</p>
<p>So, while both value types and reference types are non-nullable the way they are so differs in three important ways:</p>
<ol class="arabic simple">
<li><p>Value types are non-nullable regardless of whether we turn on the <code class="docutils literal notranslate"><span class="pre">Nullable</span></code> setting or not. The <code class="docutils literal notranslate"><span class="pre">Nullable</span></code> setting only affects the nullability of reference types.</p></li>
<li><p>A program that assigns <code class="docutils literal notranslate"><span class="pre">null</span></code> to a value type can <em>not</em> be compiled while a program that assigns <code class="docutils literal notranslate"><span class="pre">null</span></code> to a reference type <em>can</em> be. In the case of value types you get a compilation error but in the case of reference types you only get a warning.</p></li>
<li><p>Assigning <code class="docutils literal notranslate"><span class="pre">null</span></code> to a value type causes an error at type-checking while assigning <code class="docutils literal notranslate"><span class="pre">null</span></code> to a non-nullable reference type causes a warning during null-state analysis if that code can be reached.</p></li>
</ol>
<p>The third point can be driven home by asking yourself why one of the examples below is a compileable program while the other is not.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">string</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">;</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">false</span><span class="p">)</span>
<span class="w">  </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">null</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-output notranslate"><div class="highlight"><pre><span></span><span class="go">warning CS0162: Unreachable code detected</span>

<span class="go">Build succeeded.</span>
</pre></div>
</div>
<p>In the case above, we generate unreachable code (line 3).
Since the statement that assigns <code class="docutils literal notranslate"><span class="pre">null</span></code> to our non-nullable variable isn’t ever executed this is compileable (but pointless).</p>
<p>Compare this to the case below where we try to assign <code class="docutils literal notranslate"><span class="pre">null</span></code> to a value type but wrap it in a conditional that’s always false which means that it will never happen.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">string</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">;</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">false</span><span class="p">)</span>
<span class="w">  </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-output notranslate"><div class="highlight"><pre><span></span><span class="go">error CS0029: Cannot implicitly convert type &#39;int&#39; to &#39;string&#39;</span>
</pre></div>
</div>
<p>In this case we get a type-error even if the code cannot ever be reached.
This is because the error is emitted by type-checking rather than null-state static analysis.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>In the <a class="reference external" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-messages/nullable-warnings">C# manual</a> you can find a summary of all the warnings you can get as a consequence of enabling nullable reference types.</p>
</div>
<p>Remember how we said that you can use the question mark symbol (<code class="docutils literal notranslate"><span class="pre">?</span></code>) to turn a value type, which is non-nullable by default, into a nullable value type?
With the setting <code class="docutils literal notranslate"><span class="pre">Nullable</span></code> enabled reference types are, as we have seen, now also non-nullable.
We can however, just like with value types, turn any non-nullable reference type into a nullable reference type by appending a question mark to the type name.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">string?</span><span class="w"> </span><span class="n">nullableString</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">null</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-output notranslate"><div class="highlight"><pre><span></span><span class="go">Build succeeded.</span>
</pre></div>
</div>
</section>
<section id="null-state-static-analysis">
<span id="id2"></span><h2>Null-state static analysis<a class="headerlink" href="#null-state-static-analysis" title="Permalink to this heading">#</a></h2>
<p>The null-state static analysis of the C# compiler is actually quite sophisticated.
According to <a class="reference external" href="https://docs.microsoft.com/en-us/dotnet/csharp/nullable-references">the documentation</a>, the compiler can tag a variable as <code class="docutils literal notranslate"><span class="pre">not-null</span></code> in two ways:</p>
<ol class="arabic simple">
<li><p>If a variable has been assigned a value that is known to not be <code class="docutils literal notranslate"><span class="pre">null</span></code>.</p></li>
<li><p>If a variable has already been checked against <code class="docutils literal notranslate"><span class="pre">null</span></code> and has not been modified since.</p></li>
</ol>
<p>In all other cases, the variable is tagged as <code class="docutils literal notranslate"><span class="pre">maybe-null</span></code>.
Or in other words, in all other cases, the compiler cannot guarantee that the variable doesn’t contain the value <code class="docutils literal notranslate"><span class="pre">null</span></code>.</p>
<p>If we want to convert a value contained in a variable which has been tagged as <code class="docutils literal notranslate"><span class="pre">maybe-null</span></code> to a non-nullable type then we must first check whether the value actually is <code class="docutils literal notranslate"><span class="pre">null</span></code>.
Only if we can show that the value isn’t in fact <code class="docutils literal notranslate"><span class="pre">null</span></code> are we allowed to convert the value into a type which is non-nullable.
If we don’t check first then the compiler will complain and we’ll get a warning.</p>
<p>Take, for example, the concept of reading input from the user using the method <code class="docutils literal notranslate"><span class="pre">Console.ReadLine</span></code>.
If we read the <a class="reference external" href="https://docs.microsoft.com/en-us/dotnet/api/system.console.readline?view=net-6.0">documentation</a> for the method then we can see that it doesn’t return a <code class="docutils literal notranslate"><span class="pre">string</span></code> but a <code class="docutils literal notranslate"><span class="pre">string?</span></code>.
Meaning it doesn’t return a non-nullable string but a nullable string.</p>
<p>In the documentation we can see that we get <code class="docutils literal notranslate"><span class="pre">null</span></code> when there are no more lines available to read from standard input.
When we are running our program interactively and the user types in a response to our <code class="docutils literal notranslate"><span class="pre">Console.ReadLine</span></code> call then we never actually see <code class="docutils literal notranslate"><span class="pre">null</span></code>.
However, since it can occurr if we run the program non-interactively the compiler cannot guarantee that the result of <code class="docutils literal notranslate"><span class="pre">Console.ReadLine</span></code> is not <code class="docutils literal notranslate"><span class="pre">null</span></code> in our program and hence cannot tag the result as <code class="docutils literal notranslate"><span class="pre">not-null</span></code>.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">string?</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Console</span><span class="p">.</span><span class="n">ReadLine</span><span class="p">();</span>
<span class="kt">string</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
</pre></div>
</div>
<p>The variable <code class="docutils literal notranslate"><span class="pre">x</span></code> in the example above is therefore tagged as <code class="docutils literal notranslate"><span class="pre">maybe-null</span></code>.
Since we have a value that’s possibly <code class="docutils literal notranslate"><span class="pre">null</span></code> we “cannot” store it in a non-nullable variable and consequently get a warning if we try to:</p>
<div class="highlight-output notranslate"><div class="highlight"><pre><span></span><span class="go">warning CS8600: Converting null literal or possible null value to non-nullable type.</span>
</pre></div>
</div>
<p>Note that I put “cannot” within air quotes above since it is, as we’ve already discussed, slightly dishonest to say that non-nullable reference types cannot store the value <code class="docutils literal notranslate"><span class="pre">null</span></code> since they actually can.
We merely get a compiler warning.
In the next section we will however see how we can turn these warnings into errors which means that we no longer need the air quotes.</p>
<p>Ok, but is it possible to convert a nullable reference type to a non-nullable reference type if the value is tagged as <code class="docutils literal notranslate"><span class="pre">not-null</span></code>?
Yes, it is.
In the example below, we assign the variable <code class="docutils literal notranslate"><span class="pre">x</span></code> a literal string and not <code class="docutils literal notranslate"><span class="pre">null</span></code>.
This causes <code class="docutils literal notranslate"><span class="pre">x</span></code> to be tagged as <code class="docutils literal notranslate"><span class="pre">not-null</span></code> which means that we can safely and implicitly convert our <code class="docutils literal notranslate"><span class="pre">string?</span></code> which is nullable to a <code class="docutils literal notranslate"><span class="pre">string</span></code> which is non-nullable.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">string?</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Hello&quot;</span><span class="p">;</span>
<span class="kt">string</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-output notranslate"><div class="highlight"><pre><span></span><span class="go">Build succeeded.</span>
</pre></div>
</div>
<p>So what do we do in the case of our <code class="docutils literal notranslate"><span class="pre">ReadLine</span></code> example?
Of course we would like the highest grade of safety in our programs.
To avoid run-time errors we would of course like to use the non-nullable type <code class="docutils literal notranslate"><span class="pre">string</span></code> rather than the nullable type <code class="docutils literal notranslate"><span class="pre">string?</span></code>.
Are we doomed to having to resort to nullable types as soon as we have the possibility of <code class="docutils literal notranslate"><span class="pre">null</span></code>?
No, not at all.</p>
<p>Remember how we said that the compiler’s static null-state analysis can tag a variable as <code class="docutils literal notranslate"><span class="pre">not-null</span></code> if we’ve “checked it against <code class="docutils literal notranslate"><span class="pre">null</span></code>”?
What does this mean?
It simply means that we take our variable, stick it in a conditional, and check if the value of our variable is <code class="docutils literal notranslate"><span class="pre">null</span></code>.
In the branch where the variable is determined to not be <code class="docutils literal notranslate"><span class="pre">null</span></code> the variable is tagged as <code class="docutils literal notranslate"><span class="pre">not-null</span></code>.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">string?</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Console</span><span class="p">.</span><span class="n">ReadLine</span><span class="p">();</span>
<span class="kt">string</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">null</span><span class="p">)</span>
<span class="w">  </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="c1">// Here x is tagged as not-null.</span>
</pre></div>
</div>
<div class="highlight-output notranslate"><div class="highlight"><pre><span></span><span class="go">Build succeeded.</span>
</pre></div>
</div>
<p>Of course, we’re left with the question of what to do in the else-branch of the if-statement in the example above.
But, then again, this is precisely the power of static type-checking and static null-state analysis.
This is precisly what we’re looking for when trying to eliminate the billion dollar mistake called <code class="docutils literal notranslate"><span class="pre">null</span></code>.
We’ve not actually introduced more paths to our program.
We’ve merely made paths that we’re previously implicit and possibly lead to run-time errors, explicit so that we can ensure that they don’t lead to run-time errors.</p>
<p>Hopefully you can however see the bigger picture.
If you have something that <em>might be</em> <code class="docutils literal notranslate"><span class="pre">null</span></code> then you cannot convert it into something that’s <em>certainly not</em> <code class="docutils literal notranslate"><span class="pre">null</span></code> without first checking whether you actually have <code class="docutils literal notranslate"><span class="pre">null</span></code>.
If not, then I strongly advise you to return this this section after having read those chapters.</p>
</section>
<section id="warnings-as-errors">
<h2>Warnings as errors<a class="headerlink" href="#warnings-as-errors" title="Permalink to this heading">#</a></h2>
<p>Due to the immense risk of suffering run-time errors at the hand of <code class="docutils literal notranslate"><span class="pre">null</span></code> references I <em>strongly recommend</em> that you configure your project so that the compiler emits <em>errors</em> instead of <em>warnings</em>.
This means that it is impossible to compile your program and subsequently impossible to run it.</p>
<p>Configuring your project to treat <code class="docutils literal notranslate"><span class="pre">Nullable</span></code> warnings as errors is simple.
Open your <code class="docutils literal notranslate"><span class="pre">.csproj</span></code> file, and locate the line that enables the <code class="docutils literal notranslate"><span class="pre">Nullable</span></code> setting and add another line that sets the property <code class="docutils literal notranslate"><span class="pre">WarningsAsErrors</span></code> to the property <code class="docutils literal notranslate"><span class="pre">Nullable</span></code>.
The two lines should look like this:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;WarningsAsErrors&gt;</span>Nullable<span class="nt">&lt;/WarningsAsErrors&gt;</span>
<span class="nt">&lt;Nullable&gt;</span>enable<span class="nt">&lt;/Nullable&gt;</span>
</pre></div>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>I <strong>strongly recommend</strong> that you configure your projects so that the compiler emits <em>errors</em> instead of <em>warnings</em> upon possible null references.</p>
</div>
<p>I can only assume that the C# language designers chose to emit warnings instead of errors since many developers would be faced with a sea of errors if they kept programming as usual.
In my mind however, this sea of errors is a very good thing.
It only goes to show how very <em>risky</em> our code is.</p>
<p>We should not be concerned about the large number of errors that we have to get rid of to make our code compile, we should be concerned about why we write such code in the first place.
Remember the quote by <span id="id3">Martin [<a class="reference internal" href="../chapters/bibliography.html#id5" title="R. C. Martin. Clean Agile: Back to Basics. Robert C. Martin Series. Pearson Education, Limited, 2019. ISBN 9780135781869. URL: https://geni.us/fLFTJ.">2019</a>]</span> we discussed in the chapter on <a class="reference internal" href="../chapters/comments.html#comments"><span class="std std-ref">comments</span></a>?
“The only way to go fast, is to go well.”
If you don’t buy this argument, you might as well not bother with static typing at all.</p>
<div class="admonition danger">
<p class="admonition-title">Danger</p>
<p>All following code examples in this book will assumed that you are treating null reference warnings as errors.</p>
</div>
<p>When we’ve turned on the setting for treating nullable warnings as errors it is suddenly slightly more truthful to claim that <code class="docutils literal notranslate"><span class="pre">null</span></code> is not a member of any non-nullable reference type.
It still holds however that errors are emitted in a slightly different fashion since they follow as a consequence of null state analysis rather than type-checking.
So even if we treat nullable warnings as errors we are still able to compile code that assigns <code class="docutils literal notranslate"><span class="pre">null</span></code> to a non-nullable reference type if the compiler can prove that said code is never executed.</p>
</section>
<section id="null-forgiving-operator">
<h2>Null-forgiving operator<a class="headerlink" href="#null-forgiving-operator" title="Permalink to this heading">#</a></h2>
<p>Finally we must talk about the null-forgiving operator.
The null-state static analyzer isn’t perfect which means sometimes it tags a value as <code class="docutils literal notranslate"><span class="pre">maybe-null</span></code> even though it actually never is <code class="docutils literal notranslate"><span class="pre">null</span></code>.</p>
<p>In the silly example below we are declaring a nullable integer (<code class="docutils literal notranslate"><span class="pre">int?</span></code>) and initialize it to the non-null value <code class="docutils literal notranslate"><span class="pre">1</span></code>.
We then use a condition to say that if the value is <code class="docutils literal notranslate"><span class="pre">2</span></code>, which of course it is not, then and only then will we change the value to <code class="docutils literal notranslate"><span class="pre">null</span></code>.
The value will of course never be changed to <code class="docutils literal notranslate"><span class="pre">null</span></code> since the variable is always initialized to <code class="docutils literal notranslate"><span class="pre">1</span></code>.
If we try to compile the code however we still get an error (assuming that we are treating null reference warnings as errors).</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">int?</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">2</span><span class="p">)</span><span class="w">  </span><span class="c1">// This condition is false.</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">null</span><span class="p">;</span><span class="w">  </span><span class="c1">// So this line will never run.</span>

<span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">x</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-output notranslate"><div class="highlight"><pre><span></span><span class="go">error CS8629: Nullable value type may be null.</span>
</pre></div>
</div>
<p>Apologies again for using conditionals before we’ve talked about <span class="xref myst">selection</span>.
Hopefully you see the general idea.
We’re using enough <span class="xref myst">indirection</span> for the compiler to be unable to determine that the value won’t ever be <code class="docutils literal notranslate"><span class="pre">null</span></code>.</p>
<p>The conflicting part in our example is the last one where we try to convert a nullable integer to a regular integer.
To solve this issue we could use the null-forgiving operator which is a bang (<code class="docutils literal notranslate"><span class="pre">!</span></code>).
By appending the null-forgiving operator to our variable name we tell the compiler that even if it is has tagged the value as <code class="docutils literal notranslate"><span class="pre">maybe-null</span></code> we know for a fact that it cannot be <code class="docutils literal notranslate"><span class="pre">null</span></code> and that the value hence should be retagged as <code class="docutils literal notranslate"><span class="pre">not-null</span></code>.
Notice the bang in the rewriting of the last line below.
This makes the program compile and run just fine.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">x</span><span class="o">!</span><span class="p">;</span>
</pre></div>
</div>
<p>It should be noted that the program in our example is pointless in multiple ways and that it of course never should be encountered in any real world setting.
A more realistic example would be if you want to depend on some code that you cannot rewrite and that this code returns something nullable but you know that you use the code in a way such that you <em>never</em> encounter <code class="docutils literal notranslate"><span class="pre">null</span></code>.
This makes sense, but is risky.
If you’re going to do this I highly recommend creating a wrapper to centralize and encapsulate this logic.
See for example the chapter on <span class="xref myst">adapter pattern</span>.</p>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>The null-forgiving operator should be <em>used with extreme caution</em>.
There are very few scenarios that actually <em>require</em> it and in all other cases you can rewrite the code that you depend on to avoid introducing possible <code class="docutils literal notranslate"><span class="pre">null</span></code> states in the first place.
Treat the cause of the problem, not the symptoms.
The null-forgiving operator is a way to treat the symptoms.</p>
<p>All scenarios that require the null-forgiving operator involve code or states that you don’t control, so think long and hard if it isn’t possible to rewrite your code to avoid the problem in the first place.
Avoiding the introduction of <code class="docutils literal notranslate"><span class="pre">null</span></code> in the first place is a much better solution.</p>
<p>As soon as you introduce the null-forgiving operator you are back at the mercy of null-state run-time errors.</p>
</div>
</section>
<section id="void">
<h2>Void<a class="headerlink" href="#void" title="Permalink to this heading">#</a></h2>
<p>In terms of set theory, you can think of the type <code class="docutils literal notranslate"><span class="pre">void</span></code> as the empty set.
In theory, there are no elements of type <code class="docutils literal notranslate"><span class="pre">void</span></code>.
Compare this to the type <code class="docutils literal notranslate"><span class="pre">null</span></code> which is a singleton set, that only contains the value with the same name, namely <code class="docutils literal notranslate"><span class="pre">null</span></code>.
Consequently you couldn’t possible store a reference to something of type <code class="docutils literal notranslate"><span class="pre">void</span></code> in a variable.</p>
<p>We have not yet talked about <span class="xref myst">methods</span>, so the type <code class="docutils literal notranslate"><span class="pre">void</span></code> will not make much sense before we get there.
For now I therefore simply want to mention that methods have, what’s known as, return types and if a method doesn’t return a value then we say that it’s return type is <code class="docutils literal notranslate"><span class="pre">void</span></code>.
It’s quite intutive really.
If a method doesn’t return a value, but all methods must state what the type is of the things that it returns then it makes sense to say that the method returns things of type <code class="docutils literal notranslate"><span class="pre">void</span></code>.
Since there are no values of type <code class="docutils literal notranslate"><span class="pre">void</span></code> the method cannot ever return a value.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>This is way beyond the scope of this book, but due to the fact that you can declare pointers of type <code class="docutils literal notranslate"><span class="pre">void</span></code> the case could be made that <code class="docutils literal notranslate"><span class="pre">void</span></code> is a singleton set.
If you’re keen to learn more about this, see the page on <a class="reference external" href="https://docs.microsoft.com/en-ca/dotnet/csharp/language-reference/unsafe-code#pointer-types">Pointer types</a> in the documentation.</p>
</div>
</section>
<section id="exercises">
<h2>Exercises<a class="headerlink" href="#exercises" title="Permalink to this heading">#</a></h2>
<div class="exercise admonition" id="old/nothingness-exercise-0">

<p class="admonition-title"></p>
<section id="exercise-content">
<p>What do the terms “nullable” and “non-nullable” mean in the context of types?</p>
</section>
</div>
<div class="exercise admonition" id="old/nothingness-exercise-1">

<p class="admonition-title"></p>
<section id="exercise-content">
<p>With the nullable reference types setting turned on in C#, both reference types and value types are non-nullable. However, they are non-nullable in slightly different ways, how? Give an example.</p>
<p>Hint: Think about the difference between null-state analysis and type-checking.</p>
</section>
</div>
<div class="exercise admonition" id="old/nothingness-exercise-2">

<p class="admonition-title"></p>
<section id="exercise-content">
<p>What is null-state static analysis in C#?</p>
</section>
</div>
<div class="exercise admonition" id="old/nothingness-exercise-3">

<p class="admonition-title"></p>
<section id="exercise-content">
<p>What do we mean when we say that the C# compiler tags variables as <code class="docutils literal notranslate"><span class="pre">not-null</span></code> or <code class="docutils literal notranslate"><span class="pre">maybe-null</span></code>?</p>
</section>
</div>
<div class="exercise admonition" id="old/nothingness-exercise-4">

<p class="admonition-title"></p>
<section id="exercise-content">
<p>Write some code that generates a null reference warning.</p>
</section>
</div>
<div class="exercise admonition" id="old/nothingness-exercise-5">

<p class="admonition-title"></p>
<section id="exercise-content">
<p>How can we determine whether a particular variable has been tagged <code class="docutils literal notranslate"><span class="pre">maybe-null</span></code> or <code class="docutils literal notranslate"><span class="pre">not-null</span></code>?
Give an example in code.</p>
</section>
</div>
<div class="exercise admonition" id="old/nothingness-exercise-6">

<p class="admonition-title"></p>
<section id="exercise-content">
<p>How can we convert a value tagged as <code class="docutils literal notranslate"><span class="pre">maybe-null</span></code> to a value tagged as <code class="docutils literal notranslate"><span class="pre">not-null</span></code> <em>without using</em> the null-forgiving operator?
Give an example in code.</p>
</section>
</div>
<div class="exercise admonition" id="old/nothingness-exercise-7">

<p class="admonition-title"></p>
<section id="exercise-content">
<p>How can we convert a value tagged as <code class="docutils literal notranslate"><span class="pre">maybe-null</span></code> to a value tagged as <code class="docutils literal notranslate"><span class="pre">not-null</span></code> <em>by using</em> the null-forgiving operator?
Give an example in code.</p>
</section>
</div>
<div class="exercise admonition" id="old/nothingness-exercise-8">

<p class="admonition-title"></p>
<section id="exercise-content">
<p>Does the following code compile? Why or why not?
Assume that we compile with the nullable reference types setting enabled and treat nullable warnings as errors.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">string?</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Hello&quot;</span><span class="p">;</span>
<span class="kt">string</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
</pre></div>
</div>
</section>
</div>
<div class="exercise admonition" id="old/nothingness-exercise-9">

<p class="admonition-title"></p>
<section id="exercise-content">
<p>Does the following code compile? Why or why not?
Assume that we compile with the nullable reference types setting enabled and treat nullable warnings as errors.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">string?</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;A&quot;</span><span class="p">;</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;B&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">null</span><span class="p">;</span>
<span class="kt">string</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
</pre></div>
</div>
</section>
</div>
<div class="exercise admonition" id="old/nothingness-exercise-10">

<p class="admonition-title"></p>
<section id="exercise-content">
<p>Does the following code compile? Why or why not?
Assume that we compile with the nullable reference types setting enabled and treat nullable warnings as errors.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">string?</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;A&quot;</span><span class="p">;</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;B&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">null</span><span class="p">;</span>
<span class="kt">string</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="o">!</span><span class="p">;</span><span class="w"> </span><span class="c1">// &lt;-- Note the exclamation mark!</span>
</pre></div>
</div>
</section>
</div>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: ".net-csharp"
        },
        kernelOptions: {
            name: ".net-csharp",
            path: "./old"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = '.net-csharp'</script>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; All rights reserved. By using this site, you agree to our use of cookies for Google Analytics.
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Nothingness</a><ul>
<li><a class="reference internal" href="#nullable-value-types">Nullable value types</a></li>
<li><a class="reference internal" href="#nullable-reference-types">Nullable reference types</a></li>
<li><a class="reference internal" href="#null-state-static-analysis">Null-state static analysis</a></li>
<li><a class="reference internal" href="#warnings-as-errors">Warnings as errors</a></li>
<li><a class="reference internal" href="#null-forgiving-operator">Null-forgiving operator</a></li>
<li><a class="reference internal" href="#void">Void</a></li>
<li><a class="reference internal" href="#exercises">Exercises</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script src="https://www.googletagmanager.com/gtag/js?id=G-V69WNXD095"></script>
    <script src="../_static/custom.js"></script>
    <script src="../_static/analytics.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js"></script>
    <script src="../_static/scripts/furo.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </body>
</html>