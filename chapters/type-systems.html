
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>18. Type systems &#8212; The Object Oriented Way</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/exercise.css" />
    <link rel="stylesheet" type="text/css" href="../_static/style.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="19. Nothingness" href="nothingness.html" />
    <link rel="prev" title="17. Type-checking" href="type-checking.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-V69WNXD095"></script>
<script>
                    window.dataLayer = window.dataLayer || [];
                    function gtag(){ dataLayer.push(arguments); }
                    gtag('js', new Date());
                    gtag('config', 'G-V69WNXD095');
                </script>

  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
      
      
      <h1 class="site-logo" id="site-title">The Object Oriented Way</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../index.html">
                    The Object Oriented Way
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Fundamentals
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="sets.html">
   1. 🟠 Sets
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="functions.html">
   2. 🟢 Functions
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="algorithms.html">
   3. 🟠 Algorithms
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="computation.html">
   4. 🟠 Computation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="terminals.html">
   5. Terminals
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="syntax.html">
   6. 🟢 Syntax
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="semantics.html">
   7. 🟢 Semantics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="compilation.html">
   8. 🟠 Compilation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="execution.html">
   9. 🟢 Execution
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="interpretation.html">
   10. 🟢 Interpretation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="errors.html">
   11. 🟢 Errors
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="documentation.html">
   12. Documentation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="comments.html">
   13. 🟢 Comments
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="values.html">
   14. 🟢 Values
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="variables.html">
   15. 🟢 Variables
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="data-types.html">
   16. 🟢 Data types
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="type-checking.html">
   17. 🟢 Type-checking
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   18. 🟢 Type systems
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="nothingness.html">
   19. 🟠 Nothingness
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="type-hierarchies.html">
   20. Type hierarchies
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="abstraction.html">
   21. Abstraction / Modeling
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="indirection.html">
   22. Indirection
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="paradigms.html">
   23. Paradigms
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="business-logic.html">
   24. Business logic
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="debugging.html">
   25. Debugging
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="io.html">
   26. I/O
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Procedural programming
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="statements.html">
   1. Statements
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="expressions.html">
   2. Expressions
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="operators.html">
   3. Operators
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="type-conversions.html">
   4. Type conversions
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="arrays.html">
   5. Arrays
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="syntactic-sugar.html">
   6. Syntactic sugar
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="indentation.html">
   7. Indentation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="selection.html">
   8. Selection
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="iteration.html">
   9. Iteration
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="mutability.html">
   10. Mutability
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="type-testing.html">
   11. Type testing
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="value-and-reference-semantics.html">
   12. Value and reference semantics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="simple-types.html">
   13. Simple types
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="static-methods.html">
   14. Static methods (procedures)
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="purity.html">
   15. Purity
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="static-classes.html">
   16. Static classes (Modules)
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="data-structures.html">
   17. Data structures
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="composition.html">
   18. Composition
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="overloading.html">
   19. Overloading
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="recursion.html">
   20. Recursion
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="scope.html">
   21. Scope
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="namespaces.html">
   22. Namespaces
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="basic-exceptions.html">
   23. Exceptions (part 1)
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="stack-traces.html">
   24. Stack traces
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Object oriented programming
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="pillars.html">
   1. Pillars
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="objects.html">
   2. Objects
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="classes.html">
   3. Classes
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="fields.html">
   4. Fields
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="constructors.html">
   5. Constructors
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="instance-methods.html">
   6. Instance methods
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="type-signatures.html">
   7. Type signatures
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="instance-variables.html">
   8. Instance variables
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="basic-access-modifiers.html">
   9. Access modifiers (basic).
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="properties.html">
   10. Properties
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="object-composition-1.html">
   11. Direct object composition
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="object-composition-2.html">
   12. Indirect object composition
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="immutable-objects.html">
   13. Immutable objects
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="interfaces.html">
   14. Interfaces
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="subtype-polymorphism.html">
   15. Subtype polymorphism
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="inheritance.html">
   16. Inheritance
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="overriding.html">
   17. Overriding
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="hiding.html">
   18. Hiding
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="advanced-access-modifiers.html">
   19. Access modifiers (advanced)
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="object-type-conversions.html">
   20. Type conversions (of objects)
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="advanced-exceptions.html">
   21. Advanced exceptions
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="static.html">
   22. Static
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="prototypes.html">
   23. Prototypes
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="object-composition-3.html">
   24. Abstract indirect object composition
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="base-class-library.html">
   25. Base class library
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="boxing.html">
   26. Boxing
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="structure-types.html">
   27. Structure types
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="anonymous-types.html">
   28. Anonymous types
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="generics.html">
   29. Generics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="variance.html">
   30. Variance
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="business-objects.html">
   31. Business objects
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Object oriented design
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="requirements.html">
   1. Requirements
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="correctness.html">
   2. Correctness
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="maintainability.html">
   3. Maintainability
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="code-smells.html">
   4. Code smells and anti-patterns
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="coupling.html">
   5. Coupling
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="cohesion.html">
   6. Cohesion
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="refactoring.html">
   7. Refactoring
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="design-principles.html">
   8. Design principles
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="single-responsibility-principle.html">
   9. Single responsibility principle
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="interface-segregation-principle.html">
   10. Interface segregation principle
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="deep-classes.html">
   11. Deep classes
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="types-over-tests.html">
   12. Types over tests
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="define-errors-out-of-existence.html">
   13. Define errors out of existence
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="liskov-substitution-principle.html">
   14. Liskov substitution principle
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="open-closed-principle.html">
   15. Open-closed principle
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="dependency-inversion-principle.html">
   16. Dependency inversion principle
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="composition-over-inheritance.html">
   17. Composition over inheritance
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="documentation-driven-development.html">
   18. Documentation-driven development
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Advanced object oriented programming
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="design-patterns.html">
   1. Design patterns
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="strategy-pattern.html">
   2. Strategy pattern
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="delegates.html">
   3. Delegates
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="extension-methods.html">
   4. Extension methods
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="adapter-pattern.html">
   5. Adapter pattern
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="bridge-pattern.html">
   6. Bridge pattern
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="lambdas.html">
   7. Lambdas
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="abstract-factory-pattern.html">
   8. Abstract factory pattern
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="iterator-pattern.html">
   9. Iterator pattern
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="enumerators.html">
   10. Enumerators
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="indexers.html">
   11. Indexers
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="linq.html">
   12. LINQ
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="observer-pattern.html">
   13. Observer pattern
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="events.html">
   14. Events
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="visitor-pattern.html">
   15. Visitor pattern
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="pattern-matching.html">
   16. Pattern matching
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Epilogue
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="reading.html">
   Suggested reading
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="bibliography.html">
   Bibliography
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>
<a href="https://github.com/chrokh/the-oo-way/issues/new?title=Issue%20on%20page%20%2Fchapters/type-systems.html&body=Your%20issue%20content%20here."
   class="headerbtn"
   data-toggle="tooltip"
data-placement="bottom"
title="Open an issue"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>

</a>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="../_sources/chapters/type-systems.md"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.md</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#static-vs-dynamic">
   18.1. Static vs dynamic
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#manifested-vs-inferred">
   18.2. Manifested vs inferred
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#nominal-vs-structural">
   18.3. Nominal vs structural
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#duck-typing">
   18.4. Duck typing
  </a>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Type systems</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#static-vs-dynamic">
   18.1. Static vs dynamic
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#manifested-vs-inferred">
   18.2. Manifested vs inferred
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#nominal-vs-structural">
   18.3. Nominal vs structural
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#duck-typing">
   18.4. Duck typing
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section class="tex2jax_ignore mathjax_ignore" id="type-systems">
<h1><span class="section-number">18. </span>Type systems<a class="headerlink" href="#type-systems" title="Permalink to this headline">#</a></h1>
<p>C# is a statically and nominally typed language with manifested types.
In this chapter we’ll talk about what that means.
A type system lets us assign a type to each, so called, term, in a program.
In C#, all <a class="reference internal" href="variables.html"><span class="doc std std-doc">variables</span></a>, <a class="reference internal" href="variables.html#constants"><span class="std std-ref">constants</span></a>, <a class="reference internal" href="expressions.html#expressions"><span class="std std-ref">expressions that return values</span></a>, and methods have a type.</p>
<p>A language with types is said to have a type system and type systems can be classified in a number of dimensions that we’ll discuss in this chapter.</p>
<ul class="simple">
<li><p>A type system is either <a class="reference internal" href="#static-vs-dynamic"><span class="std std-ref">statically or dynamically typed</span></a>. This is also simply known as static or dynamic and refers to whether type-checking occurs at compile-time or at run-time.</p></li>
<li><p>Types in a typed language are either <a class="reference internal" href="#manifested-vs-inferred"><span class="std std-ref">manifested or inferred</span></a>. This regards whether types are explicitly stated in the code by the programmer or whether the types are automatically inferred by the type-checker. You can think of the latter case as the compiler figuring out whatever types must have been used where.</p></li>
<li><p>Types in a typed language are either <a class="reference internal" href="#nominal-vs-structural"><span class="std std-ref">nominal, structural, or duck typed</span></a>. This refers to whether types are distinguished from one another by means of their names, their structure, or their usage.</p></li>
</ul>
<section id="static-vs-dynamic">
<span id="id1"></span><h2><span class="section-number">18.1. </span>Static vs dynamic<a class="headerlink" href="#static-vs-dynamic" title="Permalink to this headline">#</a></h2>
<p>Whether a language is statically typed or dynamically typed dictates whether <a class="reference internal" href="type-checking.html"><span class="doc std std-doc">type-checking</span></a> occurs at <a class="reference internal" href="compilation.html#compilation"><span class="std std-ref">compile-time</span></a> or at <a class="reference internal" href="execution.html#execution"><span class="std std-ref">run-time</span></a>.
Colloquially we refer to this as the language being static or dynamic.</p>
<p>Hopefully you can recall how we, in the chapter on <a class="reference internal" href="errors.html#errors"><span class="std std-ref">errors</span></a> discussed that compile-time errors ought to be preferred over run-time errors since they guarantee that anytime we see a compile-time error we are saved from all errors that could occur as a consequence of this but at run-time, meaning when the application is running.</p>
<p>By the same token, static typing ought to be preferred over dynamic typing since it gives us type-safety at compile-time instead of at run-time.
Meaning that anytime we get a type error at compile-time we are saved from all other errors that could occur as a consequence of this but at run-time, meaning when the application is running.</p>
<div class="exercise admonition" id="chapters/type-systems-exercise-0">

<p class="admonition-title"><span class="caption-number">Exercise 18.1 </span></p>
<section id="exercise-content">
<p>What is the difference between statically typed and dynamically typed languages?</p>
</section>
</div>
<p>Some statically typed languages, such as C#, does however provide ways of leaving the realm of static typing at your request.
In C# we have the special type <code class="docutils literal notranslate"><span class="pre">dynamic</span></code> which can hold any run-time type.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">dynamic</span><span class="w"> </span><span class="n">v1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span><span class="w"></span>
<span class="kt">dynamic</span><span class="w"> </span><span class="n">v2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="p">;</span><span class="w"></span>
<span class="kt">dynamic</span><span class="w"> </span><span class="n">v3</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">true</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Like in some dynamically typed languages, the value does however still have a run-time type.
Check out the code example below where we check the types of the <code class="docutils literal notranslate"><span class="pre">dynamic</span></code> variables declared above.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="w"> </span><span class="n">v1</span><span class="p">.</span><span class="n">GetType</span><span class="p">()</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="w"> </span><span class="n">v2</span><span class="p">.</span><span class="n">GetType</span><span class="p">()</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="w"> </span><span class="n">v3</span><span class="p">.</span><span class="n">GetType</span><span class="p">()</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-output notranslate"><div class="highlight"><pre><span></span><span class="go">System.Int32</span>
<span class="go">System.String</span>
<span class="go">System.Boolean</span>
</pre></div>
</div>
<p>Using the keyword <code class="docutils literal notranslate"><span class="pre">dynamic</span></code> consequently doesn’t mean that we move from a world of multiple types into a world of no types at all.
It means that we move to a uni-typed world where there is only a single compile-time type, namely the type <code class="docutils literal notranslate"><span class="pre">dynamic</span></code>.</p>
<p>The compiler assumes that values given the compile-time type <code class="docutils literal notranslate"><span class="pre">dynamic</span></code> supports any operation.
This means that all operations will be allowed at compile-time.
If we invoke an operation that does in fact also exist in the run-time type, the program will compile and run.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">dynamic</span><span class="w"> </span><span class="n">x1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span><span class="w"></span>
<span class="kt">dynamic</span><span class="w"> </span><span class="n">x2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span><span class="w"></span>
<span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">x1</span><span class="w"> </span><span class="p">+</span><span class="w"> </span><span class="n">x2</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-result notranslate"><div class="highlight"><pre><span></span>2
</pre></div>
</div>
<p>If however we invoke an operation that does <em>not</em> exist in the run-time type we then the program will still compile but it will crash with an exception at run-time.
We can get a run-time error if we call a method that doesn’t exist:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">dynamic</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span><span class="w"></span>
<span class="n">z</span><span class="p">.</span><span class="n">FlyToTheMoon</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-output notranslate"><div class="highlight"><pre><span></span><span class="go">Unhandled exception. Microsoft.CSharp.RuntimeBinder.RuntimeBinderException: &#39;int&#39; does not contain a definition for &#39;FlyToTheMoon&#39;</span>
</pre></div>
</div>
<p>But we can also get a run-time error if we use a value with an operator that isn’t supported:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">dynamic</span><span class="w"> </span><span class="n">y1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span><span class="w"></span>
<span class="kt">dynamic</span><span class="w"> </span><span class="n">y2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">true</span><span class="p">;</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">y1</span><span class="w"> </span><span class="p">+</span><span class="w"> </span><span class="n">y2</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-output notranslate"><div class="highlight"><pre><span></span><span class="go">Unhandled exception. Microsoft.CSharp.RuntimeBinder.RuntimeBinderException: Operator &#39;+&#39; cannot be applied to operands of type &#39;int&#39; and &#39;bool&#39;</span>
</pre></div>
</div>
</section>
<section id="manifested-vs-inferred">
<span id="id2"></span><h2><span class="section-number">18.2. </span>Manifested vs inferred<a class="headerlink" href="#manifested-vs-inferred" title="Permalink to this headline">#</a></h2>
<p>Whether a type system uses manifested or inferred types dictates whether we, as programmers, have to explicitly state the types in our programs or whether they are inferred by the compiler.</p>
<p>Very few languages are fully inferred.
Instead, languages are usually only inferred to a certain extent, beyond which you still have to manifest the types since the type inference engine is unable to infer them.
This is a consequence of the sophistication of both the type system and the inference engine.</p>
<p>C# is traditionally a language with manifested types but we can declare, what’s known as, “implicitly typed local variables” which have inferred types.
We declare such variables by using the keyword <code class="docutils literal notranslate"><span class="pre">var</span></code> instead of the type of the variable in question.</p>
<p>In the example below, the type of the first variable is manifested while the type of the second variable is inferred.
The compile-time type of both is <code class="docutils literal notranslate"><span class="pre">int</span></code>.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">i1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// Explicitly typed (manifested)</span>
<span class="kt">var</span><span class="w"> </span><span class="n">i2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// Implicitly typed (inferred)</span>
</pre></div>
</div>
<p>It is important to realize that type inference <em>infers</em> types.
Type inference does <em>not</em> mean that we completely ignore neither compile-time nor run-time types.
The two compile-time types in the example above are just as “strong”.
The fact that one of the types is inferred while the other is manifested is irrelevant.</p>
<p>In the last section, where we discussed static and dynamic, we said that in C# we can use the keyword <code class="docutils literal notranslate"><span class="pre">dynamic</span></code> to bypass static typing.
When using the <code class="docutils literal notranslate"><span class="pre">dynamic</span></code> keyword we make the compile-time type <code class="docutils literal notranslate"><span class="pre">dynamic</span></code>.
But, when using the <code class="docutils literal notranslate"><span class="pre">var</span></code> keyword, we use type inference and let the compiler figure out what compile-time type must be used to make the program compile.
This is not the same thing.</p>
<p>When is it useful to use type inference instead of manifesting types in C#?
One use case it to avoid cluttering up our code with the names of very long type names.
We haven’t talked about these types but say you’re trying to modeling a chess board as a list of lists of positions.
A list of lists is sometimes also called a two-dimensional lists and is commonly used to represent a grid.</p>
<p>When declaring such a variable we specify the compile-time type on the left and then assign it a value with a run-time type on the right.
If we manifest the type it would look something like this:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">List</span><span class="p">&lt;</span><span class="n">List</span><span class="p">&lt;</span><span class="n">Position</span><span class="p">&gt;&gt;</span><span class="w"> </span><span class="n">board1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">List</span><span class="p">&lt;</span><span class="n">List</span><span class="p">&lt;</span><span class="n">Position</span><span class="p">&gt;&gt;&gt;();</span><span class="w"></span>
</pre></div>
</div>
<p>However, since the compile-time type is the same as the run-time type, or in other words, since the type on the left is the same as the type on the right this is a prime use case for type inference.
By using an implicitly typed local variable on the left our code is significantly less cluttered and arguably easier to read.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="w"> </span><span class="n">board2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">List</span><span class="p">&lt;</span><span class="n">List</span><span class="p">&lt;</span><span class="n">Piece</span><span class="p">&gt;&gt;&gt;();</span><span class="w"></span>
</pre></div>
</div>
<p>The compile-time type of both variables is still the same since this is type inference, not dynamic typing.
The keyword <code class="docutils literal notranslate"><span class="pre">var</span></code> is often also used in <a class="reference internal" href="iteration.html"><span class="doc std std-doc"><code class="docutils literal notranslate"><span class="pre">foreach</span></code> loops</span></a> which we will learn about later.</p>
<p>It should be noted that in the example above, the usage of an implicitly typed local variable (<code class="docutils literal notranslate"><span class="pre">var</span></code>) is optional.
However, when you have a value with an <a class="reference internal" href="anonymous-types.html#anonymous-types"><span class="std std-ref">anonymous type</span></a>, using <code class="docutils literal notranslate"><span class="pre">var</span></code> is required.
We’ll talk more about anonymous types in its own chapter, but for now I just wanted to mention that when you deal with anonymous types, you might have to use <code class="docutils literal notranslate"><span class="pre">var</span></code>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>See the <a class="reference external" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/var">official documentation</a> for more information about implicitly typed local variables (the keyword <code class="docutils literal notranslate"><span class="pre">var</span></code>).</p>
</div>
<div class="exercise admonition" id="chapters/type-systems-exercise-1">

<p class="admonition-title"><span class="caption-number">Exercise 18.2 </span></p>
<section id="exercise-content">
<p>What is the difference between manifested types and inferred types?
What does this difference mean in terms of compile-time and run-time types?</p>
</section>
</div>
<div class="exercise admonition" id="chapters/type-systems-exercise-2">

<p class="admonition-title"><span class="caption-number">Exercise 18.3 </span></p>
<section id="exercise-content">
<p>Can a language be statically typed yet still have mostly inferred types? Why?</p>
</section>
</div>
</section>
<section id="nominal-vs-structural">
<span id="id3"></span><h2><span class="section-number">18.3. </span>Nominal vs structural<a class="headerlink" href="#nominal-vs-structural" title="Permalink to this headline">#</a></h2>
<p>The third dimension in which we can classify a type system is in whether its types are nominal or structural.
Whether the type system is nominative or structural.
Again, many languages are mixes of the two but it’s easier to understand the concepts if we look at the extremes.
C# is mostly a nominally typed language but “anonymous types” (see <a class="reference external" href="https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/types/anonymous-types">documentation</a>) are arguably structurally typed.</p>
<p>The key question we’re dealing with when we’re dealing with nominal and structural typing is substitutability.
Can a particular type be used in a particular place?
More specifically we tend to talk about equivalence and subtyping.
Equivalence regards whether two types are equal while subtyping regards whether one type is a subtype of another.
We have yet to talk about <a class="reference internal" href="subtype-polymorphism.html#subtype-polymorphism"><span class="std std-ref">subtype polymorphism</span></a> so this is a bit too much too soon but think of it this way:
To determine whether a particular type can be used in a particular place we must either prove that the type of the value that we have is equivalent to the type that is expected, or we must prove that the type of the value that we have is a subtype of the type that is expected.</p>
<p>With nominal types, equivalence and subtyping is determined by means of names.
With structural types, equivalence and subtyping is determined by means of structure.</p>
<p>Every nominal type has a name and it is this name that we use to determine equivalence.
If we declare that a type is a subtype of another type then we declare that one name is a subtype of another name.
Hence, we can use the names and subtype information to determine whether a nominal type is a subtype of another nominal type.</p>
<p>Structural types on the other hand don’t need names since equivalence and subtyping is determined on the basis of structure.
If the type we need must have some properties, then we simply check whether these properties exist in the type that we have.
If the properties are present then the type that we have is deemed equivalent to the type that we need, and hence can be used.
If the properties are present but the type also has additional properties then it is considered a subtype.</p>
<p>In a structural typing system, a type can be equal to and be a subtype of many other types simultaneously.
In nominal typing two types are only ever equal if they are the same type and they are only ever in a subtype relationship if said relationship has been explicitly defined.</p>
<p>However, as an aside, in nominally typed languages it is usually not possible to let a type be a subtype of another if the type is not also “wider” than the subtype.
Consequently, nominal subtypes are also usually structural subtypes.</p>
<div class="exercise admonition" id="chapters/type-systems-exercise-3">

<p class="admonition-title"><span class="caption-number">Exercise 18.4 </span></p>
<section id="exercise-content">
<p>What is the difference between a nominative and a structural type system?</p>
</section>
</div>
</section>
<section id="duck-typing">
<h2><span class="section-number">18.4. </span>Duck typing<a class="headerlink" href="#duck-typing" title="Permalink to this headline">#</a></h2>
<p>Before we leave this chapter we must also talk about something known as duck typing.
Some argue that duck typing is another point on the dimension where we find structural and nominal typing.
Others hold that duck typing is a special case of structural typing.</p>
<p>The name “duck typing” refers to the saying:</p>
<blockquote class="epigraph">
<div><p>If it quacks like a duck, it must be a duck.</p>
</div></blockquote>
<p>In duck typing, the idea is that it doesn’t matter what something “is”, it only matters what it “does”.
Contrast this to structural typing.
Structural typing determines suitability of a type based on the full structure of the type.
But duck typing determines suitability of a type based on the properties used at run-time.</p>
<p>If we ask something whether it can quack and it can, then it doesn’t really matter if it’s a duck or not.
For our intents and purposes it behaves like a duck so let’s just keep using it like one.</p>
<p>Duck typing is usually employed in dynamic languages such as for example Ruby and JavaScript.
We’re not diving into Ruby or JavaScript in this book but here’s an example in Ruby.</p>
<div class="highlight-ruby notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Duck</span>
  <span class="k">def</span> <span class="nf">quack</span>
    <span class="nb">puts</span> <span class="s2">&quot;Quack&quot;</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Robot</span>
  <span class="k">def</span> <span class="nf">quack</span>
    <span class="nb">puts</span> <span class="s2">&quot;Brrr&quot;</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">test</span> <span class="n">duck</span>
  <span class="n">duck</span><span class="o">.</span><span class="n">quack</span>
<span class="k">end</span>

<span class="nb">test</span> <span class="no">Duck</span><span class="o">.</span><span class="n">new</span>
<span class="nb">test</span> <span class="no">Robot</span><span class="o">.</span><span class="n">new</span>
</pre></div>
</div>
<div class="highlight-output notranslate"><div class="highlight"><pre><span></span><span class="go">Quack</span>
<span class="go">Brrr</span>
</pre></div>
</div>
<p>In the example above we’re defining two types called <code class="docutils literal notranslate"><span class="pre">Duck</span></code> and <code class="docutils literal notranslate"><span class="pre">Robot</span></code>.
We’re defining a method called <code class="docutils literal notranslate"><span class="pre">test</span></code> which takes an argument and calls the method <code class="docutils literal notranslate"><span class="pre">quack</span></code> on that argument.
We’re then instantiating one duck and one robot and pass both of them to the <code class="docutils literal notranslate"><span class="pre">test</span></code> method.
Since both objects respond to the <code class="docutils literal notranslate"><span class="pre">quack</span></code> method we conclude that both are ducks.
There is no point in arguing about whether robots are not ducks.
For all intents and purposes they behave like ducks.</p>
<p>When you’ve read the chapter on <a class="reference internal" href="interfaces.html#interfaces"><span class="std std-ref">interfaces</span></a> I highly recommend that you come back to this chapter again and think about the relationship between duck types and interfaces.</p>
<div class="exercise admonition" id="chapters/type-systems-exercise-4">

<p class="admonition-title"><span class="caption-number">Exercise 18.5 </span></p>
<section id="exercise-content">
<p>What is duck typing? How does it relate to structural typing?</p>
</section>
</div>
<div class="exercise admonition" id="chapters/type-systems-exercise-5">

<p class="admonition-title"><span class="caption-number">Exercise 18.6 </span></p>
<section id="exercise-content">
<p>What is the following maxim trying to convey?
“If it quacks like a duck, it must be a duck.”</p>
</section>
</div>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./chapters"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="type-checking.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title"><span class="section-number">17. </span>Type-checking</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="nothingness.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">19. </span>Nothingness</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Christopher Okhravi<br/>
  
      &copy; Copyright 2022.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>