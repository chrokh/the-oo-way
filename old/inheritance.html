<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />
<link rel="index" title="Index" href="../genindex.html" /><link rel="search" title="Search" href="../search.html" />

    <!-- Generated with Sphinx 5.0.2 and Furo 2023.03.27 -->
        <title>Inheritance - The Object Oriented Way</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?digest=fad236701ea90a88636c2a8c73b44ae642ed2a53" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/exercise.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    <link rel="stylesheet" type="text/css" href="../_static/style.css" />
    
    


<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">The Object Oriented Way</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand centered" href="../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo" src="../_static/logo.png" alt="Logo"/>
  </div>
  
  <span class="sidebar-brand-text">The Object Oriented Way</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Chapters</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../chapters/syntax.html">1. Syntax</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/hello-world.html">2. Hello world</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/compilation.html">3. Compilation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/execution.html">4. Execution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/interpretation.html">5. Interpretation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/comments.html">6. Comments</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/values.html">7. Values</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/variables.html">8. Variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/data-types.html">9. Data types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/expressions.html">10. Expressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/arithmetic-operators.html">11. Arithmetic operators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/equality-operators.html">12. Equality operators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/relational-operators.html">13. Relational operators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/logical-operators.html">14. Logical operators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/assignment-operator.html">15. Assignment operator</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/precedence.html">16. Precedence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/associativity.html">17. Associativity</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/constants.html">18. Constants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/statements.html">19. Statements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/type-inference.html">20. Type inference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/type-checking.html">21. Type checking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/floating-point-types.html">22. Floating-point types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/enumeration-types.html">23. Enumeration types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/selection-statements.html">24. Selection statements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/selection-expressions.html">25. Selection expressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/iteration.html">26. Iteration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/arrays.html">27. Arrays</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/reference-types.html">28. Reference types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/value-types.html">29. Value types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/local-functions.html">30. Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/fat-arrows.html">31. Fat arrows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/recursion.html">32. Recursion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/namespaces.html">33. Namespaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/objects.html">34. Objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/classes.html">35. Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/access-modifiers.html">36. Access modifiers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/fields.html">37. Fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/constructors.html">38. Constructors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/the-this-keyword.html">39. The <code class="docutils literal notranslate"><span class="pre">this</span></code> keyword</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/instance-methods.html">40. Instance methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/encapsulation.html">41. Encapsulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/auto-implemented-properties.html">42. Auto-implemented properties</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/manually-implemented-properties.html">43. Manually implemented properties</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/object-initializers.html">44. Object initializers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/read-only-fields.html">45. Read-only fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/read-only-properties.html">46. Read-only properties</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/computed-properties.html">47. Computed properties</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/required-properties-and-fields.html">48. Required properties and fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/init-only-properties.html">49. Init-only properties</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/instance-method-overloading.html">50. Instance method overloading</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/constructor-overloading.html">51. Constructor overloading</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/static-fields.html">52. Static fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/static-constructors.html">53. Static constructors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/static-methods.html">54. Static methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/static-properties.html">55. Static properties</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/static-classes.html">56. Static classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/top-level-statements.html">57. Top-level statements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/object-composition.html">58. Object composition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/interfaces.html">59. Interfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/subtype-polymorphism.html">60. Subtype polymorphism</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/run-time-type-vs-compile-time-type.html">61. Run-time type vs compile-time type</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/dynamic-dispatch.html">62. Dynamic dispatch</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/multiple-interfaces.html">63. Multiple interfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/interface-default-implementations.html">64. Interface default implementations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/inheritance.html">65. Inheritance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/overriding.html">66. Overriding</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/hiding.html">67. Hiding</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/the-base-keyword.html">68. The <code class="docutils literal notranslate"><span class="pre">base</span></code> keyword</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/constructor-chaining.html">69. Constructor chaining</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/protected.html">70. Protected access modifier</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/abstract-classes.html">71. Abstract classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/interface-inheritance.html">72. Interface inheritance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/type-conversions.html">73. Type conversions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/upcasting.html">74. Upcasting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/downcasting.html">75. Downcasting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/everything-is-an-object.html">76. Everything is an object</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/uml-class-diagrams.html">77. UML class diagrams</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/maintainability.html">78. Maintainability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/refactoring.html">79. Refactoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/generics.html">80. Generics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/generic-types.html">81. Generic types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/generics-and-type-errors.html">82. Generics and type errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/generic-supertypes.html">83. Generic supertypes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/generic-methods.html">84. Generic methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/type-parameter-constraints.html">85. Type parameter constraints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/collections.html">86. Collections</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/collection-initializers.html">87. Collection initializers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/replace-conditional-with-polymorphism.html">88. Replace conditional with polymorphism</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/dependency-injection.html">89. Dependency injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/composition-over-inheritance.html">90. Composition over inheritance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/strategy-pattern.html">91. Strategy pattern</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/bridge-pattern.html">92. Bridge pattern</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/delegates.html">93. Delegates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/generic-delegates.html">94. Generic delegates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/built-in-delegates.html">95. Built-in delegates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/multicast-delegates.html">96. Multicast delegates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/lambdas.html">97. Lambdas</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/observer-pattern.html">98. Observer pattern</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/events.html">99. Events</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/event-conventions.html">100. Event conventions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/event-driven-programming.html">101. Event-driven programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/iterator-pattern.html">102. Iterator pattern</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/enumerables.html">103. Enumerables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/the-yield-statement.html">104. The <code class="docutils literal notranslate"><span class="pre">yield</span></code> statement</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/anonymous-types.html">105. Anonymous types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/linq.html">106. LINQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/variance.html">107. Variance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/covariance.html">108. Covariance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/contravariance.html">109. Contravariance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/invariance.html">110. Invariance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/liskov-substitution-principle.html">111. Liskov substitution principle</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/variant-classes.html">112. Variant classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/variant-delegates.html">113. Variant delegates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/variant-generic-delegates.html">114. Variant generic delegates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/variant-generic-interfaces.html">115. Variant generic interfaces</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Labs</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../labs/replace-conditional-with-polymorphism.html">Lab: Replace conditional with polymorphism</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/generics.html">Lab: Generics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/generic-types.html">Lab: Generic types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/generic-supertypes.html">Lab: Generic Supertypes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/type-parameter-constraints.html">Lab: Type parameter constraints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/composition-over-inheritance.html">Lab: Composition over Inheritance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/bridge-pattern.html">Lab: Bridge Pattern</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/delegates.html">Lab: Delegates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/lambdas.html">Lab: Lambdas</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/observer-pattern.html">Lab: Observer Pattern</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/events.html">Lab: Events</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/iterator-pattern.html">Lab: Iterator pattern</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/enumerables.html">Lab: Enumerables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/the-yield-keyword.html">Lab: The <code class="docutils literal notranslate"><span class="pre">yield</span></code> keyword</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section class="tex2jax_ignore mathjax_ignore" id="inheritance">
<h1>Inheritance<a class="headerlink" href="#inheritance" title="Permalink to this heading">#</a></h1>
<section id="motivation">
<h2>Motivation<a class="headerlink" href="#motivation" title="Permalink to this heading">#</a></h2>
<p>Inheritance, in object oriented languages, tend to serve two purposes.</p>
<ol class="arabic simple">
<li><p>Inheriting the Inheritance is a mechanism that allows a subtype to either inherit or <a class="reference internal" href="#overriding"><span class="std std-ref">override</span></a> instance members from its supertype. This can be thought of as inheriting the implementation and is sometimes called “implementation inheritance”.</p></li>
<li><p>Inheritance causes the subtype to be substitutable for the supertype in the sense of subtype polymorphism. This can be thought of as inheriting the type and is sometimes called “interface inheritance”.</p></li>
</ol>
<p>We have already discussed the benefits of subtype polymorphism in the chapters on <a class="reference internal" href="interfaces.html"><span class="doc std std-doc">interfaces</span></a> and <a class="reference internal" href="subtype-polymorphism.html"><span class="doc std std-doc">subtype polymorphism</span></a>.
We have thus already dealt with the second point above, and will in this chapter therefore mostly focus on the first.
Namely, that of using inheritance to eliminate duplication by allowing subclasses to use code from its superclass.</p>
<p>Nevertheless, it is of <em>vital importance</em> to realize that these two purposes always go hand-in-hand.
Whenever we declare that a subclass inherits from a superclass, then we are always and without exception also declaring that the former is a subtype of the latter.</p>
<p>In other words, inheritance always leads to subtype polymorphism which means that we must take care not violate the <a class="reference internal" href="liskov-substitution-principle.html#liskov-substitution-principle"><span class="std std-ref">Liskov substitution principle</span></a> or else we are in for a world of hurt.</p>
<div class="admonition danger">
<p class="admonition-title">Danger</p>
<p>Inheritance must <em>not</em> blindly be used for <em>code reuse</em> without respecting the rules of substitutability.</p>
</div>
</section>
<section id="definition">
<h2>Definition<a class="headerlink" href="#definition" title="Permalink to this heading">#</a></h2>
<p>Inheritance is a binary directed relationship between two (possibly <a class="reference internal" href="abstract-classes.html"><span class="doc std std-doc">abstract</span></a>) classes or <span class="xref myst">interfaces</span>.
Similar to the terminology used in <a class="reference internal" href="subtype-polymorphism.html"><span class="doc std std-doc">subtype polymorphism</span></a> we refer to the two parties as sub/child/derived class/type and super/parent/base class/type.
The subclass inherits both type and members from its superclass.
We’ll discuss <a class="reference internal" href="abstract-classes.html"><span class="doc std std-doc">abstract classes</span></a> in a separate chapter.</p>
<p>To declare that a class is a subclass of another class in C# we use the same syntax as we use when declaring that the class implements some <a class="reference internal" href="interfaces.html"><span class="doc std std-doc">interface</span></a>.
In other words, we write a colon (<code class="docutils literal notranslate"><span class="pre">:</span></code>) after the class name and then the name of the superclass.</p>
<p>In the example below, we declare that the class <code class="docutils literal notranslate"><span class="pre">Child</span></code> inherits from the class <code class="docutils literal notranslate"><span class="pre">Parent</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Parent</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Child</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">Parent</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
<div>
    <div id='dotnet-interactive-this-cell-9801.Microsoft.DotNet.Interactive.Http.HttpPort' style='display: none'>
        The below script needs to be able to find the current output cell; this is an easy method to get it.
    </div>
    <script type='text/javascript'>
async function probeAddresses(probingAddresses) {
    function timeout(ms, promise) {
        return new Promise(function (resolve, reject) {
            setTimeout(function () {
                reject(new Error('timeout'))
            }, ms)
            promise.then(resolve, reject)
        })
    }

    if (Array.isArray(probingAddresses)) {
        for (let i = 0; i < probingAddresses.length; i++) {

            let rootUrl = probingAddresses[i];

            if (!rootUrl.endsWith('/')) {
                rootUrl = `${rootUrl}/`;
            }

            try {
                let response = await timeout(1000, fetch(`${rootUrl}discovery`, {
                    method: 'POST',
                    cache: 'no-cache',
                    mode: 'cors',
                    timeout: 1000,
                    headers: {
                        'Content-Type': 'text/plain'
                    },
                    body: probingAddresses[i]
                }));

                if (response.status == 200) {
                    return rootUrl;
                }
            }
            catch (e) { }
        }
    }
}

function loadDotnetInteractiveApi() {
    probeAddresses(["http://10.1.0.8:2048/", "http://127.0.0.1:2048/"])
        .then((root) => {
        // use probing to find host url and api resources
        // load interactive helpers and language services
        let dotnetInteractiveRequire = require.config({
        context: '9801.Microsoft.DotNet.Interactive.Http.HttpPort',
                paths:
            {
                'dotnet-interactive': `${root}resources`
                }
        }) || require;

            window.dotnetInteractiveRequire = dotnetInteractiveRequire;

            window.configureRequireFromExtension = function(extensionName, extensionCacheBuster) {
                let paths = {};
                paths[extensionName] = `${root}extensions/${extensionName}/resources/`;
                
                let internalRequire = require.config({
                    context: extensionCacheBuster,
                    paths: paths,
                    urlArgs: `cacheBuster=${extensionCacheBuster}`
                    }) || require;

                return internalRequire
            };
        
            dotnetInteractiveRequire([
                    'dotnet-interactive/dotnet-interactive'
                ],
                function (dotnet) {
                    dotnet.init(window);
                },
                function (error) {
                    console.log(error);
                }
            );
        })
        .catch(error => {console.log(error);});
    }

// ensure `require` is available globally
if ((typeof(require) !==  typeof(Function)) || (typeof(require.config) !== typeof(Function))) {
    let require_script = document.createElement('script');
    require_script.setAttribute('src', 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js');
    require_script.setAttribute('type', 'text/javascript');
    
    
    require_script.onload = function() {
        loadDotnetInteractiveApi();
    };

    document.getElementsByTagName('head')[0].appendChild(require_script);
}
else {
    loadDotnetInteractiveApi();
}

    </script>
</div></div></div>
</div>
<section id="inheriting-members">
<h3>Inheriting members<a class="headerlink" href="#inheriting-members" title="Permalink to this heading">#</a></h3>
<p>We’ve said that the subclass inherits all (<a class="reference internal" href="basic-access-modifiers.html#access-modifiers"><span class="std std-ref">public or protected</span></a>) members of the superclass.
What does this mean in practice?
In the code below the the subclass contains no instance members.
We do however declare that the subclass inherits from a superclass which does contain a public instance method.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Parent</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">InheritedMethod</span><span class="w"> </span><span class="p">()</span>
<span class="w">    </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Implemented in parent.&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Child</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">Parent</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<p>Since the superclass defines an instance method we can of course call that instance method on instances of that type.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">Parent</span><span class="w"> </span><span class="n">parent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Parent</span><span class="p">();</span>
<span class="n">parent</span><span class="p">.</span><span class="n">InheritedMethod</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Implemented in parent.
</pre></div>
</div>
</div>
</div>
<p>However, since the subclass <em>inherits</em> from that superclass we can also call that instance method on all instances of the subclass.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">Child</span><span class="w"> </span><span class="n">child</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Child</span><span class="p">();</span><span class="w"> </span><span class="c1">// Note that this is the subtype!</span>
<span class="n">child</span><span class="p">.</span><span class="n">InheritedMethod</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Implemented in parent.
</pre></div>
</div>
</div>
</div>
</section>
<section id="inheriting-types">
<h3>Inheriting types<a class="headerlink" href="#inheriting-types" title="Permalink to this heading">#</a></h3>
<p>We’ve also said that the subclass inherits the type of the superclass in the sense of <a class="reference internal" href="subtype-polymorphism.html"><span class="doc std std-doc">subtype polymorphism</span></a>.
What does this mean?
It means that we can treat instances of the subclass as if they were instances of the superclass.
It means that we can let the compile-time type be the superclass and the run-time type be any subclasses of that superclass.</p>
<p>Given the two types <code class="docutils literal notranslate"><span class="pre">Parent</span></code> and <code class="docutils literal notranslate"><span class="pre">Child</span></code> that we defined above we can therefore assign instances of type <code class="docutils literal notranslate"><span class="pre">Child</span></code> to variables of type <code class="docutils literal notranslate"><span class="pre">Parent</span></code>.
Note how the compile-time type is the general type, while the run-time type is the special type in the code below.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">Parent</span><span class="w"> </span><span class="n">child</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Child</span><span class="p">();</span>
</pre></div>
</div>
</div>
</div>
<p>Of course, the compiler still allows us to invoke the instance method <code class="docutils literal notranslate"><span class="pre">InheritedMethod</span></code> since it’s defined in <code class="docutils literal notranslate"><span class="pre">Parent</span></code> and our compile-time type is <code class="docutils literal notranslate"><span class="pre">Parent</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">child</span><span class="p">.</span><span class="n">InheritedMethod</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Implemented in parent.
</pre></div>
</div>
</div>
</div>
</section>
<section id="overriding">
<span id="id1"></span><h3>Overriding<a class="headerlink" href="#overriding" title="Permalink to this heading">#</a></h3>
<p>We’ve established that a subclass inherits all members from its superclass.
However, if an <a class="reference internal" href="instance-methods.html"><span class="doc std std-doc">instance method</span></a> or <a class="reference internal" href="properties.html"><span class="doc std std-doc">instance property</span></a> in the superclass is marked as <code class="docutils literal notranslate"><span class="pre">virtual</span></code> then it is possible for the subclass to <code class="docutils literal notranslate"><span class="pre">override</span></code> that implementation.
Meaning, it is possible for the subclass to define its own specialized implementation for that member to use instead of the one defined by the superclass.</p>
<p>Starting from the same code as above, let’s rewrite it so that the instance method in the superclass is marked as <code class="docutils literal notranslate"><span class="pre">virtual</span></code> so that we can <code class="docutils literal notranslate"><span class="pre">override</span></code> it in the subclass.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Parent</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="k">virtual</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">OverriddenMethod</span><span class="w"> </span><span class="p">()</span>
<span class="w">    </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Implemented in PARENT.&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Child</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">Parent</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">OverriddenMethod</span><span class="w"> </span><span class="p">()</span>
<span class="w">    </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Implemented in CHILD.&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<p>If we instantiate a <code class="docutils literal notranslate"><span class="pre">Parent</span></code>, treat it as a <code class="docutils literal notranslate"><span class="pre">Parent</span></code>, and then call the instance method, we will execute the implementation defined in <code class="docutils literal notranslate"><span class="pre">Parent</span></code>.
Unsurprising.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">Parent</span><span class="w"> </span><span class="n">parentAsParent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Parent</span><span class="p">();</span>
<span class="n">parentAsParent</span><span class="p">.</span><span class="n">OverriddenMethod</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Implemented in PARENT.
</pre></div>
</div>
</div>
</div>
<p>What is also unsurprising, is that if we instantiate a <code class="docutils literal notranslate"><span class="pre">Child</span></code>, treat it as a <code class="docutils literal notranslate"><span class="pre">Child</span></code>, and then call the instance method, we will execute the implementation defined in <code class="docutils literal notranslate"><span class="pre">Child</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">Child</span><span class="w"> </span><span class="n">childAsChild</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Child</span><span class="p">();</span>
<span class="n">childAsChild</span><span class="p">.</span><span class="n">OverriddenMethod</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Implemented in CHILD.
</pre></div>
</div>
</div>
</div>
<p>However, what you might find surprising is that if we instantiate a <code class="docutils literal notranslate"><span class="pre">Child</span></code>, <em>but</em> treat it as a <code class="docutils literal notranslate"><span class="pre">Parent</span></code>, and then call the instance method, we will execute the implementation defined in <code class="docutils literal notranslate"><span class="pre">Child</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">Parent</span><span class="w"> </span><span class="n">childAsParent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Child</span><span class="p">();</span>
<span class="n">childAsParent</span><span class="p">.</span><span class="n">OverriddenMethod</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Implemented in CHILD.
</pre></div>
</div>
</div>
</div>
<p>At first you might find this counter-intuitive.
But, this is the entire point of overriding.
Due to subtype polymorphism you can then treat all subclasses of the same superclass interchangibly, but whenever you call a method marked as <code class="docutils literal notranslate"><span class="pre">virtual</span></code> that has been overridden in the subclass then the specialized method in the subclass is the one that’s being executed.
This behavior is also summarized in <code class="xref std std-numref docutils literal notranslate"><span class="pre">tbl:inheritance:override</span></code>.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>When overriding, which implementation is executed is determined by the <em>run-time type</em> and not the compile-time type.
This behavior was discussed in the chapter on <a class="reference internal" href="subtype-polymorphism.html"><span class="doc std std-doc">subtype polymorphism</span></a>.</p>
</div>
<p>Remember, when overriding, what implementation to run is determined by the run-time type.</p>
<div class="table-wrapper docutils container" id="tbl-inheritance-override">
<table class="docutils align-default" id="tbl-inheritance-override">
<caption><span class="caption-text">What implementation is executed depends on the run-time type in the case of overriding and the compile-time type in the case of hiding.</span><a class="headerlink" href="#tbl-inheritance-override" title="Permalink to this table">#</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Compile-time type</p></th>
<th class="head"><p>Run-time type</p></th>
<th class="head"><p>Executed implementation (overriding)</p></th>
<th class="head"><p>Executed implementation (hiding)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Parent</p></td>
<td><p>Parent</p></td>
<td><p>Parent</p></td>
<td><p>Parent</p></td>
</tr>
<tr class="row-odd"><td><p>Child</p></td>
<td><p>Child</p></td>
<td><p>Child</p></td>
<td><p>Child</p></td>
</tr>
<tr class="row-even"><td><p>Parent</p></td>
<td><p>Child</p></td>
<td><p>Child</p></td>
<td><p>Parent</p></td>
</tr>
</tbody>
</table>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>It should be noted that in some languages, we don’t mark what methods are virtual, we mark what methods are not virtual.
In C#, instance methods are non-virtual unless otherwise specified.
In Java, instance methods are virtual unless otherwise specified.</p>
</div>
</section>
<section id="hiding">
<span id="id2"></span><h3>Hiding<a class="headerlink" href="#hiding" title="Permalink to this heading">#</a></h3>
<p>Before moving on we need to talk about a feature that isn’t actually only related to inheritance but often comes up when we fail to remember to use the keyword <code class="docutils literal notranslate"><span class="pre">override</span></code>.
That feautre is “method hiding”.
Let’s say we have a method in a subclass with the same signature as one in the superclass and we mark the method in the subclass as <code class="docutils literal notranslate"><span class="pre">new</span></code> rather than <code class="docutils literal notranslate"><span class="pre">override</span></code>.
In this case we are <em>not</em> using overriding.
Instead we are using what is known as “hiding”.
We say that the method in the subclass “hides” the method in the superclass.</p>
<p>In <code class="xref std std-numref docutils literal notranslate"><span class="pre">tbl:inheritance:override</span></code> you can see how hiding is different from overriding.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>When hiding, which implementation is executed is determined by the <em>compile-time type</em> and not the run-time type.</p>
</div>
<p>Let’s go through all the same examples as before.
This time however we will mark the method as <code class="docutils literal notranslate"><span class="pre">new</span></code> in the subclass.
Whether we mark the method in the superclass as <code class="docutils literal notranslate"><span class="pre">virtual</span></code> or not does not matter.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Parent</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">HiddenMethod</span><span class="w"> </span><span class="p">()</span>
<span class="w">    </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Implemented in PARENT.&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Child</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">Parent</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">HiddenMethod</span><span class="w"> </span><span class="p">()</span>
<span class="w">    </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Implemented in CHILD.&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<p>If we instantiate a <code class="docutils literal notranslate"><span class="pre">Parent</span></code>, treat it as a <code class="docutils literal notranslate"><span class="pre">Parent</span></code>, and then call the instance method, we will execute the implementation defined in <code class="docutils literal notranslate"><span class="pre">Parent</span></code>.
Still, unsurprising.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">Parent</span><span class="w"> </span><span class="n">parentAsParent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Parent</span><span class="p">();</span>
<span class="n">parentAsParent</span><span class="p">.</span><span class="n">HiddenMethod</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Implemented in PARENT.
</pre></div>
</div>
</div>
</div>
<p>What is also still unsurprising, is that if we instantiate a <code class="docutils literal notranslate"><span class="pre">Child</span></code>, treat it as a <code class="docutils literal notranslate"><span class="pre">Child</span></code>, and then call the instance method, we will execute the implementation defined in <code class="docutils literal notranslate"><span class="pre">Child</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">Child</span><span class="w"> </span><span class="n">childAsChild</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Child</span><span class="p">();</span>
<span class="n">childAsChild</span><span class="p">.</span><span class="n">HiddenMethod</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Implemented in CHILD.
</pre></div>
</div>
</div>
</div>
<p>However, when we are hiding rather than overriding, instantiate a <code class="docutils literal notranslate"><span class="pre">Child</span></code> but treat it as a <code class="docutils literal notranslate"><span class="pre">Parent</span></code>, and then call the instance method, we will execute the implementation defined in <code class="docutils literal notranslate"><span class="pre">Parent</span></code>.
Remember, when hiding, what implementation to run is determined by the compile-time type.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">Parent</span><span class="w"> </span><span class="n">childAsParent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Child</span><span class="p">();</span>
<span class="n">childAsParent</span><span class="p">.</span><span class="n">HiddenMethod</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Implemented in PARENT.
</pre></div>
</div>
</div>
</div>
</section>
<section id="constructor-chaining">
<h3>Constructor chaining<a class="headerlink" href="#constructor-chaining" title="Permalink to this heading">#</a></h3>
<p>Remember the concept of <span class="xref myst">constructor chaining</span>?
We said that a constructor can call another constructor by using the keyword <code class="docutils literal notranslate"><span class="pre">this</span></code>.
In that chapter we also mentioned that when we get to inheritance we will also discuss the keyword <code class="docutils literal notranslate"><span class="pre">base</span></code>.</p>
<p>The keyword <code class="docutils literal notranslate"><span class="pre">base</span></code>, works just like the keyword <code class="docutils literal notranslate"><span class="pre">this</span></code> in that it can be used for two purposes.
It can be used for constructor chaining.
In other words it can be used to call a constructor in the base class (hence the name “base”) from a constructor in a derived class.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>If the superclass does not define a parameterless constructor then any subclass of the superclass must define how to instantiate the superclass’s constructor by using the keyword <code class="docutils literal notranslate"><span class="pre">base</span></code>.</p>
</div>
<p>Notice how the code below causes a compiler error.</p>
<div class="cell tag_raises-exception docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Parent</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="nf">Parent</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">    </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Instantiated with &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Child</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">Parent</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(7,7): error CS7036: There is no argument given that corresponds to the required parameter &#39;x&#39; of &#39;Parent.Parent(int)&#39;
</pre></div>
</div>
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
</div>
</div>
<p>Why do we get a compiler error?
Because in order to know how to construct the <code class="docutils literal notranslate"><span class="pre">Child</span></code> we must also know how to construct the <code class="docutils literal notranslate"><span class="pre">Parent</span></code>.</p>
<p>In the code below we’ve added two constructors that both call the <code class="docutils literal notranslate"><span class="pre">base</span></code> constructor and that both would, on their own, be enough to get rid of that compiler error.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Parent</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="nf">Parent</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">    </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Instantiated with &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Child</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">Parent</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="nf">Child</span><span class="w"> </span><span class="p">()</span>
<span class="w">    </span><span class="p">:</span><span class="w"> </span><span class="k">base</span><span class="p">(</span><span class="m">10</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span>

<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="nf">Child</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">    </span><span class="p">:</span><span class="w"> </span><span class="k">base</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<p>It now compiles.
Whenever we run any of the constructors of the subclass a constructor in the superclass is now also run.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">Child</span><span class="w"> </span><span class="n">child1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Child</span><span class="p">();</span>
<span class="n">Child</span><span class="w"> </span><span class="n">child2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Child</span><span class="p">(</span><span class="m">5</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Instantiated with 10
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Instantiated with 5
</pre></div>
</div>
</div>
</div>
</section>
<section id="accessing-base-members">
<h3>Accessing base members<a class="headerlink" href="#accessing-base-members" title="Permalink to this heading">#</a></h3>
<p>Just like you can use the keyword <code class="docutils literal notranslate"><span class="pre">this</span></code> to access other members in the object itself, you can use the keyword <code class="docutils literal notranslate"><span class="pre">base</span></code> to access other members in the superclass.</p>
<p>This is of course particularly useful in the case of hiding.
Meaning when we have an instance member in the subclass with the same signature as a member in the superclass but want to explicitly call the one in the superclass.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Parent</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Method</span><span class="w"> </span><span class="p">()</span>
<span class="w">    </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Called method in parent.&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Child</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">Parent</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Method</span><span class="w"> </span><span class="p">()</span>
<span class="w">    </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">base</span><span class="p">.</span><span class="n">Method</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">Child</span><span class="w"> </span><span class="n">child</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Child</span><span class="p">();</span>
<span class="n">child</span><span class="p">.</span><span class="n">Method</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Called method in parent.
</pre></div>
</div>
</div>
</div>
<p>Just like in the case of <code class="docutils literal notranslate"><span class="pre">this</span></code>, the keyword <code class="docutils literal notranslate"><span class="pre">base</span></code> refers to an object which means that we can pass around that value like any other value.</p>
</section>
</section>
<section id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this heading">#</a></h2>
<section id="sequences">
<span id="inheritance-sequences"></span><h3>Sequences<a class="headerlink" href="#sequences" title="Permalink to this heading">#</a></h3>
<p>Let’s talk about number sequences.
What is a number sequence?
Well, the natural numbers starting from 1 is one and incrementing all the way to infinity (or the maximum value for <code class="docutils literal notranslate"><span class="pre">int</span></code> in practical terms) is a sequence.
Two other sequences are those of odd and even numbers.
A more complex sequence would be for example the Fibonacci sequence which says that the next number is the sum of the two preceding numbers.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This might seem a bit esoteric at the moment, but once we’ve learned about <a class="reference internal" href="generics.html"><span class="doc std std-doc">generics</span></a> you will see how this generalizes to sequences of any type.
Then, when we get to <span class="xref myst">design patterns</span>, you will see how this is the core idea of the <span class="xref myst">iterator pattern</span>.</p>
</div>
<p>Let’s start by defining a superclass, called <code class="docutils literal notranslate"><span class="pre">Sequence</span></code>, that simply models the sequence of incrementing integers starting from the number <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<p>Have a look at the implementation below.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Sequence</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="k">virtual</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">Current</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">get</span><span class="p">;</span><span class="w"> </span><span class="k">private</span><span class="w"> </span><span class="k">set</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>

<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="k">virtual</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Next</span><span class="p">()</span>
<span class="w">    </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">Current</span><span class="o">++</span><span class="p">;</span>

<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="kt">int</span><span class="p">[]</span><span class="w"> </span><span class="nf">Take</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="p">[]</span><span class="w"> </span><span class="n">nums</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="m">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Current</span><span class="p">;</span>
<span class="w">      </span><span class="n">Next</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">nums</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<p>The class <code class="docutils literal notranslate"><span class="pre">Sequence</span></code> defines one property and two instance methods.</p>
<p>The property <code class="docutils literal notranslate"><span class="pre">Current</span></code> is of type <code class="docutils literal notranslate"><span class="pre">int</span></code>, holds the current number of the sequence, and is initialized to <code class="docutils literal notranslate"><span class="pre">0</span></code>.
Its <code class="docutils literal notranslate"><span class="pre">get</span></code> accessor is <code class="docutils literal notranslate"><span class="pre">public</span></code> while its <code class="docutils literal notranslate"><span class="pre">set</span></code> accessor is <code class="docutils literal notranslate"><span class="pre">private</span></code>.
It</p>
<p>The first instance method is called <code class="docutils literal notranslate"><span class="pre">Next</span></code> and it simply increments the <code class="docutils literal notranslate"><span class="pre">Current</span></code> number by <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
<p>Note that we’ve marked both the property <code class="docutils literal notranslate"><span class="pre">Current</span></code> and the instance method <code class="docutils literal notranslate"><span class="pre">Next</span></code> with the keyword <code class="docutils literal notranslate"><span class="pre">virtual</span></code>.
This is because we want it possible to override these members in subclasses so that the subclasses in question can implement their actual sequences.</p>
<p>Note that since the <code class="docutils literal notranslate"><span class="pre">set</span></code> accessor of the property <code class="docutils literal notranslate"><span class="pre">Current</span></code> is marked as <code class="docutils literal notranslate"><span class="pre">private</span></code> it is not overridable.
Subclasses will not have access to the <code class="docutils literal notranslate"><span class="pre">set</span></code> accessor and will thus interpret the property <code class="docutils literal notranslate"><span class="pre">Current</span></code> as a read-only property that is marked as <code class="docutils literal notranslate"><span class="pre">virtual</span></code>.</p>
<p>The second instance method is called <code class="docutils literal notranslate"><span class="pre">Take</span></code> and it takes an integer called <code class="docutils literal notranslate"><span class="pre">n</span></code> representing the number of numbers that we want from the sequence.
It calls <code class="docutils literal notranslate"><span class="pre">Next</span></code> on the sequence <code class="docutils literal notranslate"><span class="pre">n</span></code> times and puts the value of <code class="docutils literal notranslate"><span class="pre">Current</span></code> in, after each call to next, in an array that it then returns.
In other words, the method <code class="docutils literal notranslate"><span class="pre">Take</span></code> simply returns the next <code class="docutils literal notranslate"><span class="pre">n</span></code> numbers from the sequence in an array while also moving the sequence that many steps.</p>
<p>Ok, so we’ve got a basic sequence now.
Let’s try it out to make sure that it works.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Instantiate sequence.</span>
<span class="n">Sequence</span><span class="w"> </span><span class="n">seq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Sequence</span><span class="p">();</span>

<span class="c1">// Take 10 elements.</span>
<span class="kt">int</span><span class="p">[]</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">seq</span><span class="p">.</span><span class="n">Take</span><span class="p">(</span><span class="m">10</span><span class="p">);</span>

<span class="c1">// Print the elements.</span>
<span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">String</span><span class="p">.</span><span class="n">Join</span><span class="p">(</span><span class="s">&quot;, &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">output</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0, 1, 2, 3, 4, 5, 6, 7, 8, 9
</pre></div>
</div>
</div>
</div>
<p>Seems to work.
Let’s now define some subclasses of this sequence that reuses code from the superclass.</p>
<section id="step-sequence">
<h4>Step sequence<a class="headerlink" href="#step-sequence" title="Permalink to this heading">#</a></h4>
<p>Let’s define a subclass called <code class="docutils literal notranslate"><span class="pre">StepSequence</span></code> that models the series of integers that moves in increments of <code class="docutils literal notranslate"><span class="pre">steps</span></code>.
In other words, it specializes the class <code class="docutils literal notranslate"><span class="pre">Sequence</span></code> by saying that every time it moves to the next number we may move multiple steps.</p>
<p>We’re now going to look at two ways of writing this class as a subclass of <code class="docutils literal notranslate"><span class="pre">Sequence</span></code>.
Let’s start by reusing as much code as possible.
Here’s the class.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">StepSequence</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">Sequence</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">steps</span><span class="p">;</span>

<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="nf">StepSequence</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">steps</span><span class="p">)</span>
<span class="w">    </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">steps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">steps</span><span class="p">;</span>

<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Next</span><span class="p">()</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="m">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">steps</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">      </span><span class="k">base</span><span class="p">.</span><span class="n">Next</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s try it out to make sure that it works and then let’s discuss it.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">StepSequence</span><span class="w"> </span><span class="n">seq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">StepSequence</span><span class="p">(</span><span class="m">2</span><span class="p">);</span>
<span class="kt">int</span><span class="p">[]</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">seq</span><span class="p">.</span><span class="n">Take</span><span class="p">(</span><span class="m">10</span><span class="p">);</span>
<span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">String</span><span class="p">.</span><span class="n">Join</span><span class="p">(</span><span class="s">&quot;, &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">output</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0, 2, 4, 6, 8, 10, 12, 14, 16, 18
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">StepSequence</span><span class="w"> </span><span class="n">seq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">StepSequence</span><span class="p">(</span><span class="m">10</span><span class="p">);</span>
<span class="kt">int</span><span class="p">[]</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">seq</span><span class="p">.</span><span class="n">Take</span><span class="p">(</span><span class="m">10</span><span class="p">);</span>
<span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">String</span><span class="p">.</span><span class="n">Join</span><span class="p">(</span><span class="s">&quot;, &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">output</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0, 10, 20, 30, 40, 50, 60, 70, 80, 90
</pre></div>
</div>
</div>
</div>
<p>Seems to work, but let’s now talk about why.</p>
<p>It works because we’re <a class="reference internal" href="#overriding"><span class="std std-ref">overriding</span></a> the instance method <code class="docutils literal notranslate"><span class="pre">Next</span></code> with an implementation that calls the instance method <code class="docutils literal notranslate"><span class="pre">Next</span></code> in the superclass as many times as defined by the instance field <code class="docutils literal notranslate"><span class="pre">steps</span></code>.
Notice how we’re making use of the keyword <code class="docutils literal notranslate"><span class="pre">base</span></code> to differentiate between <code class="docutils literal notranslate"><span class="pre">Next</span></code> as defined in <code class="docutils literal notranslate"><span class="pre">StepSequence</span></code> and as defined in its parent <code class="docutils literal notranslate"><span class="pre">Sequence</span></code>.</p>
<p>What about code reuse?
Well, we’ve reused the property <code class="docutils literal notranslate"><span class="pre">Current</span></code> and the instance method <code class="docutils literal notranslate"><span class="pre">Take</span></code>.</p>
<p>Alright, so we said that there are at least two ways of doing this.
What’s the other way?
Well, we could also decide to ignore the way that the superclass implements <code class="docutils literal notranslate"><span class="pre">Next</span></code> and <code class="docutils literal notranslate"><span class="pre">Current</span></code> altogether and simply write our own implementation.
Have a look at the code below.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">StepSequence</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">Sequence</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">steps</span><span class="p">;</span>

<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="nf">StepSequence</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">steps</span><span class="p">)</span>
<span class="w">    </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">steps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">steps</span><span class="p">;</span>

<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">Current</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">get</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Next</span><span class="p">()</span>
<span class="w">    </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">steps</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<p>This implementation works just like the other.
However, in this implementation we’ve reused less code from the superclass.
Why?
Because we’ve also overridden the property <code class="docutils literal notranslate"><span class="pre">Current</span></code>.</p>
</section>
<section id="evens-and-odds">
<h4>Evens and odds<a class="headerlink" href="#evens-and-odds" title="Permalink to this heading">#</a></h4>
<p>Let’s build something a bit more complex.
How about sequences that generate even and odd numbers?</p>
<p>Interestingly, both the sequence of even numbers and that of odd numbers move in increments of 2.
So to model, for example, the sequence of even numbers we must figure out how to start on an even number and then consistently increment by 2.</p>
<p>Again, we find multiple ways of implementing these classes.
Let’s first talk about how we would implement them as subclasses of <code class="docutils literal notranslate"><span class="pre">StepSequence</span></code>.
If these inherit from the class <code class="docutils literal notranslate"><span class="pre">StepSequence</span></code> then we don’t need to worry about changing the implementation of <code class="docutils literal notranslate"><span class="pre">Next</span></code>.
Instead, we just need to make sure that we start on an even or odd number (depending on which class we are talking about) and that we set the parameter <code class="docutils literal notranslate"><span class="pre">steps</span></code> to <code class="docutils literal notranslate"><span class="pre">2</span></code>.</p>
<p>Unfortunately that requires to add a constructor to the implementation of <code class="docutils literal notranslate"><span class="pre">StepSequence</span></code> so that we can control the starting number.
Have a look at the code below.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Updated implementation.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">StepSequence</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">Sequence</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">current</span><span class="p">;</span>
<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">steps</span><span class="p">;</span>

<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="nf">StepSequence</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">steps</span><span class="p">)</span>
<span class="w">    </span><span class="p">:</span><span class="w"> </span><span class="k">this</span><span class="p">(</span><span class="n">steps</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span>

<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="nf">StepSequence</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">steps</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">initial</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="n">steps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">steps</span><span class="p">;</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">initial</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">Current</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">get</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">current</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Next</span><span class="p">()</span>
<span class="w">    </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">steps</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>We’re going to talk about the design principle known as <a class="reference internal" href="composition-over-inheritance.html"><span class="doc std std-doc">composition over inheritance</span></a> at length.
Had we used composition instead of inheritance to solve this problem we would not have been forced to change the <code class="docutils literal notranslate"><span class="pre">StepSequence</span></code> class at all.
We’ll discuss this further in the chapters on <span class="xref myst">abstract constructed</span> and <span class="xref myst">abstract injected object composition</span>.</p>
</div>
<p>With our redefined version of <code class="docutils literal notranslate"><span class="pre">StepSequence</span></code> that allows us to start a sequence at a number that we choose we are ready to subclass it in order to implement even and odd sequences.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">EvenSequence</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">StepSequence</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="nf">EvenSequence</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="k">base</span><span class="p">(</span><span class="m">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span><span class="w"> </span><span class="nc">OddSequence</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">StepSequence</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="nf">OddSequence</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="k">base</span><span class="p">(</span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">EvenSequence</span><span class="w"> </span><span class="n">evenSeq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">EvenSequence</span><span class="p">();</span>
<span class="n">OddSequence</span><span class="w"> </span><span class="n">oddSeq</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">OddSequence</span><span class="p">();</span>

<span class="kt">int</span><span class="p">[]</span><span class="w"> </span><span class="n">evens</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">evenSeq</span><span class="p">.</span><span class="n">Take</span><span class="p">(</span><span class="m">10</span><span class="p">);</span>
<span class="kt">int</span><span class="p">[]</span><span class="w"> </span><span class="n">odds</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">oddSeq</span><span class="p">.</span><span class="n">Take</span><span class="p">(</span><span class="m">10</span><span class="p">);</span>

<span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">String</span><span class="p">.</span><span class="n">Join</span><span class="p">(</span><span class="s">&quot;, &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">evens</span><span class="p">));</span>
<span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">String</span><span class="p">.</span><span class="n">Join</span><span class="p">(</span><span class="s">&quot;, &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">odds</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0, 2, 4, 6, 8, 10, 12, 14, 16, 18
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1, 3, 5, 7, 9, 11, 13, 15, 17, 19
</pre></div>
</div>
</div>
</div>
<p>Again, we said that we would talk about two ways to build these sequences.
One other way of building a sequence of even numbers and one of odds is to again simply override not only the method <code class="docutils literal notranslate"><span class="pre">Next</span></code> but also the property <code class="docutils literal notranslate"><span class="pre">Current</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Alterantive implementation.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">EvenSequence</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">Sequence</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>

<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">Current</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">get</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">current</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Next</span><span class="w"> </span><span class="p">()</span>
<span class="w">    </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="m">2</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">String</span><span class="p">.</span><span class="n">Join</span><span class="p">(</span><span class="s">&quot;, &quot;</span><span class="p">,</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">EvenSequence</span><span class="p">().</span><span class="n">Take</span><span class="p">(</span><span class="m">10</span><span class="p">)));</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0, 2, 4, 6, 8, 10, 12, 14, 16, 18
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Alterantive implementation.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">OddSequence</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">Sequence</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span>

<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">Current</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">get</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">current</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Next</span><span class="w"> </span><span class="p">()</span>
<span class="w">    </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="m">2</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">String</span><span class="p">.</span><span class="n">Join</span><span class="p">(</span><span class="s">&quot;, &quot;</span><span class="p">,</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">OddSequence</span><span class="p">().</span><span class="n">Take</span><span class="p">(</span><span class="m">10</span><span class="p">)));</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1, 3, 5, 7, 9, 11, 13, 15, 17, 19
</pre></div>
</div>
</div>
</div>
<p>These too work just fine, but once again we’re reusing less and overriding more.
At some point it will be pointless to keep using inheritance instead of composition.</p>
</section>
<section id="palindromic-numbers">
<h4>Palindromic numbers<a class="headerlink" href="#palindromic-numbers" title="Permalink to this heading">#</a></h4>
<p>Let’s now have a look at a sequence which isn’t so trivial.
How about the sequence of palindromic numbers?
A palindrome is a string whose value remains the same when reversed.
A palindromic number is a number that behaves like a palindrome when treated like a string.
Some examples of palindromic numbers include <code class="docutils literal notranslate"><span class="pre">2</span></code>, <code class="docutils literal notranslate"><span class="pre">11</span></code>, <code class="docutils literal notranslate"><span class="pre">505</span></code>, and <code class="docutils literal notranslate"><span class="pre">110011</span></code>.</p>
<p>The class below is called <code class="docutils literal notranslate"><span class="pre">PalindromicSequence</span></code> and implements this idea.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">PalindromicSequence</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">Sequence</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Next</span><span class="w"> </span><span class="p">()</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">base</span><span class="p">.</span><span class="n">Next</span><span class="p">();</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">isPalindromic</span><span class="p">())</span>
<span class="w">      </span><span class="n">Next</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">isPalindromic</span><span class="w"> </span><span class="p">()</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="kt">string</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Current</span><span class="p">.</span><span class="n">ToString</span><span class="p">();</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="m">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">number</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">number</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">number</span><span class="p">[</span><span class="n">number</span><span class="p">.</span><span class="n">Length</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m">1</span><span class="p">])</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">false</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">true</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There’s probably more efficient ways of implementing this algorithm but I’ve opted for this way since it is fairly readable in the context.</p>
</div>
<p>Notice how the overridden implementation of the instance method is <span class="xref myst">recursive</span>.
It calls <code class="docutils literal notranslate"><span class="pre">base.Next</span></code> and then calls itself again unless the number we have found is a palindrome.
The method could also have been written non-recursively, using <span class="xref myst">iteration</span>, like this:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">base</span><span class="p">.</span><span class="n">Next</span><span class="p">();</span>
<span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">isPalindromic</span><span class="p">());</span>
</pre></div>
</div>
<p>Also note how we opted to inherit from <code class="docutils literal notranslate"><span class="pre">Sequence</span></code> and not from <code class="docutils literal notranslate"><span class="pre">StepSequence</span></code> since the palindrome finding algorithm that we’ve implemented must move in increments of <code class="docutils literal notranslate"><span class="pre">1</span></code> when looking for the next palindrome.</p>
<p>Let’s try it out to make sure that it works.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">PalindromicSequence</span><span class="w"> </span><span class="n">sequence</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">PalindromicSequence</span><span class="p">();</span>
<span class="kt">int</span><span class="p">[]</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sequence</span><span class="p">.</span><span class="n">Take</span><span class="p">(</span><span class="m">10</span><span class="p">);</span>
<span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">String</span><span class="p">.</span><span class="n">Join</span><span class="p">(</span><span class="s">&quot;, &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">output</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0, 1, 2, 3, 4, 5, 6, 7, 8, 9
</pre></div>
</div>
</div>
</div>
</section>
<section id="square-numbers">
<h4>Square numbers<a class="headerlink" href="#square-numbers" title="Permalink to this heading">#</a></h4>
<p>Let’s do one final sequence before we move on.
Here’s something that’s quite different from what we’ve seen so far.
How about the sequence of square numbers?</p>
<p>The <code class="docutils literal notranslate"><span class="pre">n</span></code>:th number in the sequence of squares is simply defined as <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">*</span> <span class="pre">n</span></code>.
Ideally we’d like to use that formula rather than having to step through each number and check whether that number happens to be a <code class="docutils literal notranslate"><span class="pre">square</span></code> number.
Have a look at the implementation below.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">SquareSequence</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">Sequence</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>

<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">Current</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">get</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="p">))</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="m">2</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Next</span><span class="p">()</span>
<span class="w">    </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">n</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">SquareSequence</span><span class="w"> </span><span class="n">sequence</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">SquareSequence</span><span class="p">();</span>
<span class="kt">int</span><span class="p">[]</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sequence</span><span class="p">.</span><span class="n">Take</span><span class="p">(</span><span class="m">10</span><span class="p">);</span>
<span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">String</span><span class="p">.</span><span class="n">Join</span><span class="p">(</span><span class="s">&quot;, &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">output</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0, 1, 3, 6, 10, 15, 21, 28, 36, 45
</pre></div>
</div>
</div>
</div>
<p>In the implementation above, we’re only reusing the method <code class="docutils literal notranslate"><span class="pre">Take</span></code>.
The rest has been overridden.
Had we not overridden <code class="docutils literal notranslate"><span class="pre">Current</span></code> we would have had to write a much more complicated algorithm.
Have a look at the alternative solution below.</p>
<div class="cell docutils container" id="sequence-recursive-duplication">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">SquareSequence</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">Sequence</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Next</span><span class="p">()</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">base</span><span class="p">.</span><span class="n">Next</span><span class="p">();</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">isSquare</span><span class="p">())</span>
<span class="w">      </span><span class="n">Next</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">isSquare</span><span class="w"> </span><span class="p">()</span>
<span class="w">    </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">Math</span><span class="p">.</span><span class="n">Sqrt</span><span class="p">(</span><span class="n">Current</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">Math</span><span class="p">.</span><span class="n">Sqrt</span><span class="p">(</span><span class="n">Current</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Current</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">String</span><span class="p">.</span><span class="n">Join</span><span class="p">(</span><span class="s">&quot;, &quot;</span><span class="p">,</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">SquareSequence</span><span class="p">().</span><span class="n">Take</span><span class="p">(</span><span class="m">10</span><span class="p">)));</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0, 1, 4, 9, 16, 25, 36, 49, 64, 81
</pre></div>
</div>
</div>
</div>
<div class="admonition-key-takeaway admonition">
<p class="admonition-title">Key takeaway</p>
<p>In the latter case we tried to reuse more code by allowing ourselves use a less efficient algorithm we <em>still</em> ended up having to duplicate code.
Notice how the implementation of the recursive method <code class="docutils literal notranslate"><span class="pre">Next</span></code> in <code class="docutils literal notranslate"><span class="pre">SquareSequence</span></code> essentially is the same as the implementation of <code class="docutils literal notranslate"><span class="pre">Next</span></code> in <code class="docutils literal notranslate"><span class="pre">PalindromicSequence</span></code>.
We’ll return to this discussion in <code class="xref std std-numref docutils literal notranslate"><span class="pre">filtered-sequences-and-inheritance</span></code>.</p>
</div>
</section>
</section>
<section id="characterwise-ciphers">
<span id="inheritance-examples-characterwise"></span><h3>Characterwise ciphers<a class="headerlink" href="#characterwise-ciphers" title="Permalink to this heading">#</a></h3>
<p>Remember how we’ve been unable to get rid of the duplicated <code class="docutils literal notranslate"><span class="pre">foreach</span></code> loop present in all the <a class="reference internal" href="../chapters/methods-old.html#methods-substitution-ciphers"><span class="std std-ref">substitution ciphers</span></a>.
The only solution for  this that we’ve seen so far was given in the chapter on <a class="reference internal" href="../chapters/methods-old.html#methods-substitution-ciphers"><span class="std std-ref">methods</span></a>.
In that chapter I suggested that without some form of polymorphism we often have to resort to turning part of our algorithms into data in order to keep increasing abstraction and thus remove duplication.</p>
<p>But in this book we’re exploring object oriented programming, so we don’t want to be forced to turn our algorithms into data.
We want to let our algorithms be algorithms.</p>
<p>In this example, we’ll be able to remove the duplicated <code class="docutils literal notranslate"><span class="pre">foreach</span></code> loop from all substitution cipher classes that implement the interface <code class="docutils literal notranslate"><span class="pre">ICharToCharCipher</span></code>.
Meaning all substitution ciphers that have an encode method which works charwise and replaces each character with a single character.
The Robber’s language does <em>not</em> fit that description, but Caesar ciphers and the Leet language do so let’s use those two.</p>
<p>As alluded to in the motivation section however, it would in this case, as is often the case, be preferable to use composition over inheritance since that would allow us to eliminate all duplication.
But we’ll switch to that solution in the chapter on <span class="xref myst">abstract injected object composition</span>.</p>
<p>We’ve still got our interfaces from the chapter on <a class="reference internal" href="interfaces.html#interfaces-ciphers"><span class="std std-ref">interfaces</span></a> but these don’t really help us here.</p>
<div class="cell tag_hide-input docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">interface</span><span class="w"> </span><span class="n">ICharToCharCipher</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="nf">Encode</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="n">input</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">interface</span><span class="w"> </span><span class="n">IStringToStringCipher</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">string</span><span class="w"> </span><span class="nf">Encode</span><span class="w"> </span><span class="p">(</span><span class="kt">string</span><span class="w"> </span><span class="n">input</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">interface</span><span class="w"> </span><span class="n">ICharToStringCipher</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">string</span><span class="w"> </span><span class="nf">Encode</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="n">input</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</details>
</div>
<p>Let us just first take stock of what the duplication looks like.
Pay special attention to the two implemented methods with the signature <code class="docutils literal notranslate"><span class="pre">string</span> <span class="pre">Encode</span> <span class="pre">(string</span> <span class="pre">input)</span></code> below.
Notice how both implementations are entirely the same.</p>
<p>Let’s first have a look at the class <code class="docutils literal notranslate"><span class="pre">LeetCipher</span></code>:</p>
<div class="cell tag_hide-input docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">LeetCipher</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">ICharToCharCipher</span><span class="p">,</span><span class="w"> </span><span class="n">IStringToStringCipher</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="nf">Encode</span><span class="w"> </span><span class="p">(</span><span class="kt">string</span><span class="w"> </span><span class="n">input</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">string</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">foreach</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="n">letter</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">input</span><span class="p">)</span>
<span class="w">      </span><span class="n">output</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">Encode</span><span class="w"> </span><span class="p">(</span><span class="n">letter</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">output</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="nf">Encode</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="n">input</span><span class="p">)</span>
<span class="w">    </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="k">switch</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="sc">&#39;L&#39;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="sc">&#39;1&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;1&#39;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="sc">&#39;L&#39;</span><span class="p">,</span>
<span class="w">      </span><span class="sc">&#39;A&#39;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="sc">&#39;4&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;4&#39;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="sc">&#39;A&#39;</span><span class="p">,</span>
<span class="w">      </span><span class="sc">&#39;O&#39;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="sc">&#39;0&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;0&#39;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="sc">&#39;O&#39;</span><span class="p">,</span>
<span class="w">      </span><span class="sc">&#39;T&#39;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="sc">&#39;7&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;7&#39;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="sc">&#39;T&#39;</span><span class="p">,</span>
<span class="w">      </span><span class="sc">&#39;E&#39;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="sc">&#39;3&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;3&#39;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="sc">&#39;E&#39;</span><span class="p">,</span>
<span class="w">      </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">input</span>
<span class="w">    </span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</details>
</div>
<p>Let’s then have a look at the class <code class="docutils literal notranslate"><span class="pre">CaesarCipher</span></code>:</p>
<div class="cell tag_hide-input docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">CaesarCipher</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">ICharToCharCipher</span><span class="p">,</span><span class="w"> </span><span class="n">IStringToStringCipher</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">steps</span><span class="p">;</span>

<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="nf">CaesarCipher</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">steps</span><span class="p">)</span>
<span class="w">    </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">steps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">steps</span><span class="p">;</span>

<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="nf">Encode</span><span class="w"> </span><span class="p">(</span><span class="kt">string</span><span class="w"> </span><span class="n">input</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">string</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">foreach</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="n">letter</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">input</span><span class="p">)</span>
<span class="w">      </span><span class="n">output</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">Encode</span><span class="w"> </span><span class="p">(</span><span class="n">letter</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">output</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="nf">Encode</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="n">input</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">string</span><span class="w"> </span><span class="n">alphabet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;ABCDEFGHIJKLMNOPQRSTUVXYZ&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alphabet</span><span class="p">.</span><span class="n">IndexOf</span><span class="p">(</span><span class="n">Char</span><span class="p">.</span><span class="n">ToUpper</span><span class="p">(</span><span class="n">input</span><span class="p">));</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">newIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">steps</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">alphabet</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="o">-</span><span class="m">1</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">newIndex</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="m">0</span><span class="p">)</span>
<span class="w">        </span><span class="n">newIndex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">alphabet</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span>

<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Char</span><span class="p">.</span><span class="n">IsLower</span><span class="p">(</span><span class="n">input</span><span class="p">))</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Char</span><span class="p">.</span><span class="n">ToLower</span><span class="p">(</span><span class="n">alphabet</span><span class="p">[</span><span class="n">newIndex</span><span class="p">]);</span>
<span class="w">      </span><span class="k">else</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">alphabet</span><span class="p">[</span><span class="n">newIndex</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">input</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</details>
</div>
<p>Notice how the implementation of the method with the signature <code class="docutils literal notranslate"><span class="pre">string</span> <span class="pre">Encode</span> <span class="pre">(string</span> <span class="pre">input)</span></code> is <em>exactly</em> the same in both classes.
The only thing that’s different is in what context the method is executed, which in turn determines which <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">Encode</span> <span class="pre">(char</span> <span class="pre">input)</span></code> method is being called.</p>
<p>Again, if we at this point knew about the design principle <a class="reference internal" href="composition-over-inheritance.html"><span class="doc std std-doc">composition over inheritance</span></a> we would solve this using <span class="xref myst">abstract injected object composition</span>.
But, let’s take it one step at a time, and let’s see what we can do with regular old inheritance first.</p>
<p>Here’s the key.
Notice how the implementations of <code class="docutils literal notranslate"><span class="pre">string</span> <span class="pre">Encode</span> <span class="pre">(string</span> <span class="pre">input)</span></code> fulfill the interface <code class="docutils literal notranslate"><span class="pre">IStringToStringCipher</span></code> and depend on <code class="docutils literal notranslate"><span class="pre">ICharToCharCipher</span></code>.
It fulfills the first because the encode method itself is the only method required by that interface.
It depends on the second because the implementation of the encode method delegates to the other overload of <code class="docutils literal notranslate"><span class="pre">Encode</span></code> which takes and returns a character.</p>
<p>So, let’s introduce a superclass called <code class="docutils literal notranslate"><span class="pre">CharWiseCipher</span></code> that implements both <code class="docutils literal notranslate"><span class="pre">IStringToStringCipher</span></code> and <code class="docutils literal notranslate"><span class="pre">ICharToCharCipher</span></code>.
We’ll let this superclass behave like the <a class="reference internal" href="../chapters/algorithms.html#identity-cipher"><span class="std std-ref">identity cipher</span></a> that we also implemented in the chapter on <span class="xref myst">subtype polymorphism</span>.</p>
<p>In the identity cipher, the encode method that takes and returns a character will simply return whatever character we give it.
Similarly, the encode method that takes and returns a string ought to return whatever we give it.</p>
<p>However, instead of simply returning what we get we will choose to iterate over the input <code class="docutils literal notranslate"><span class="pre">string</span></code>, call the method <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">Encode</span> <span class="pre">(char</span> <span class="pre">input)</span></code> for each character one by one, and concatenate the results into a <code class="docutils literal notranslate"><span class="pre">string</span></code> again.
Even though the method that receives and returns a <code class="docutils literal notranslate"><span class="pre">char</span></code> will always return the same <code class="docutils literal notranslate"><span class="pre">char</span></code>
In other words, the implementation of <code class="docutils literal notranslate"><span class="pre">string</span> <span class="pre">Encode</span> <span class="pre">(string</span> <span class="pre">input)</span></code> will be the one that we are trying to unify for the other classes.</p>
<p>But why would we do such a silly thing?
Isn’t this just a waste of resources?
Why iterate over the input <code class="docutils literal notranslate"><span class="pre">string</span></code> if we’re just going to call a method for each character that always returns the same character that we give it.
Well, because we’re going to mark that silly method as <code class="docutils literal notranslate"><span class="pre">virtual</span></code>.
Which means that subclasses of <code class="docutils literal notranslate"><span class="pre">CharWiseCipher</span></code> can <code class="docutils literal notranslate"><span class="pre">override</span></code> our implementation of <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">Encode</span> <span class="pre">(char</span> <span class="pre">input)</span></code>.
If they do, then it is no longer pointless for us to iterate over the string and delegate to the overridden method.</p>
<p>Let’s look at some code.
Here’s our superclass that behaves like the identity cipher.
Pay attention to how we use the keyword <code class="docutils literal notranslate"><span class="pre">virtual</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">CharWiseCipher</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">ICharToCharCipher</span><span class="p">,</span><span class="w"> </span><span class="n">IStringToStringCipher</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="k">virtual</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="nf">Encode</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="n">input</span><span class="p">)</span>
<span class="w">    </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">input</span><span class="p">;</span>

<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="nf">Encode</span><span class="w"> </span><span class="p">(</span><span class="kt">string</span><span class="w"> </span><span class="n">input</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="kt">string</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">foreach</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="n">letter</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">input</span><span class="p">)</span>
<span class="w">      </span><span class="n">output</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">Encode</span><span class="w"> </span><span class="p">(</span><span class="n">letter</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">output</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s run it to make sure that it behaves like the identity cipher.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">CharWiseCipher</span><span class="w"> </span><span class="n">identity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">CharWiseCipher</span><span class="p">();</span>
<span class="n">identity</span><span class="p">.</span><span class="n">Encode</span><span class="p">(</span><span class="sc">&#39;x&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<p>Yup, when we pass it a <code class="docutils literal notranslate"><span class="pre">char</span></code>, we get the same <code class="docutils literal notranslate"><span class="pre">char</span></code> back.
How about a <code class="docutils literal notranslate"><span class="pre">string</span></code>?</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">identity</span><span class="p">.</span><span class="n">Encode</span><span class="p">(</span><span class="s">&quot;Hello world&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<p>Works too.
Ok, so we’ve got the superclass figured out.
Let’s create some subclasses.</p>
<p>We’ll start with <code class="docutils literal notranslate"><span class="pre">LeetCipher</span></code>.
Pay attention to how we use the keyword <code class="docutils literal notranslate"><span class="pre">override</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">LeetCipher</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">CharWiseCipher</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="nf">Encode</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="n">input</span><span class="p">)</span>
<span class="w">    </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="k">switch</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="sc">&#39;L&#39;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="sc">&#39;1&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;1&#39;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="sc">&#39;L&#39;</span><span class="p">,</span>
<span class="w">      </span><span class="sc">&#39;A&#39;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="sc">&#39;4&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;4&#39;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="sc">&#39;A&#39;</span><span class="p">,</span>
<span class="w">      </span><span class="sc">&#39;O&#39;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="sc">&#39;0&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;0&#39;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="sc">&#39;O&#39;</span><span class="p">,</span>
<span class="w">      </span><span class="sc">&#39;T&#39;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="sc">&#39;7&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;7&#39;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="sc">&#39;T&#39;</span><span class="p">,</span>
<span class="w">      </span><span class="sc">&#39;E&#39;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="sc">&#39;3&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;3&#39;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="sc">&#39;E&#39;</span><span class="p">,</span>
<span class="w">      </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">input</span>
<span class="w">    </span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<p>Hmmm.. does this really work?
Does this <code class="docutils literal notranslate"><span class="pre">LeetCipher</span></code> actually have a method that takes and returns a <code class="docutils literal notranslate"><span class="pre">string</span></code>?
Let’s try it out.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">LeetCipher</span><span class="w"> </span><span class="n">leet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">LeetCipher</span><span class="p">();</span>
<span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">leet</span><span class="p">.</span><span class="n">Encode</span><span class="p">(</span><span class="s">&quot;LEET 101&quot;</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1337 LOL
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">leet</span><span class="p">.</span><span class="n">Encode</span><span class="p">(</span><span class="s">&quot;E&quot;</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>3
</pre></div>
</div>
</div>
</div>
<p>As you can see, it actually works.
The <code class="docutils literal notranslate"><span class="pre">Encode</span></code> method that we’ve called is defined on the superclass but since our subclass inherits from the superclass we can also call the method on instances of the superclass.
Furthermore, since the <code class="docutils literal notranslate"><span class="pre">Encode</span></code> method calls the other <code class="docutils literal notranslate"><span class="pre">Encode</span></code> method which takes and receives a <code class="docutils literal notranslate"><span class="pre">char</span></code>, and since that method has been overridden in the subclass we get a cipher that no longer behaves as the identity cipher.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>This idea of having a base class with an instance method that uses another instance member that is often overridden in a subclass is known as the Template method pattern.
We’ll talk more about <span class="xref myst">design patterns</span> in a separate chapter.</p>
</div>
<p>Pretty neat, no?
Now, let’s try the <code class="docutils literal notranslate"><span class="pre">CaesarCipher</span></code>.
Same kind of drill here.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">CaesarCipher</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">CharWiseCipher</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">steps</span><span class="p">;</span>

<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="nf">CaesarCipher</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">steps</span><span class="p">)</span>
<span class="w">    </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">steps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">steps</span><span class="p">;</span>

<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="nf">Encode</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="n">input</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="kt">string</span><span class="w"> </span><span class="n">alphabet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;ABCDEFGHIJKLMNOPQRSTUVXYZ&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alphabet</span><span class="p">.</span><span class="n">IndexOf</span><span class="p">(</span><span class="n">Char</span><span class="p">.</span><span class="n">ToUpper</span><span class="p">(</span><span class="n">input</span><span class="p">));</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">newIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">steps</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">alphabet</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="o">-</span><span class="m">1</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">newIndex</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="m">0</span><span class="p">)</span>
<span class="w">        </span><span class="n">newIndex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">alphabet</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span>

<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Char</span><span class="p">.</span><span class="n">IsLower</span><span class="p">(</span><span class="n">input</span><span class="p">))</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Char</span><span class="p">.</span><span class="n">ToLower</span><span class="p">(</span><span class="n">alphabet</span><span class="p">[</span><span class="n">newIndex</span><span class="p">]);</span>
<span class="w">      </span><span class="k">else</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">alphabet</span><span class="p">[</span><span class="n">newIndex</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">input</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">CaesarCipher</span><span class="w"> </span><span class="n">leet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">CaesarCipher</span><span class="p">(</span><span class="m">2</span><span class="p">);</span>
<span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">leet</span><span class="p">.</span><span class="n">Encode</span><span class="p">(</span><span class="s">&quot;ABC&quot;</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>CDE
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">leet</span><span class="p">.</span><span class="n">Encode</span><span class="p">(</span><span class="sc">&#39;A&#39;</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>C
</pre></div>
</div>
</div>
</div>
<p>Lo and behold.
It works.</p>
</section>
<section id="interface-inheritance">
<h3>Interface inheritance<a class="headerlink" href="#interface-inheritance" title="Permalink to this heading">#</a></h3>
<p>Remember how we said that an interface can inherit from another interface?
Let me show you an example of that before we move on.
Let’s say that we’ve got an interface called <code class="docutils literal notranslate"><span class="pre">IIncrementable</span></code> which requires that whoever implements declares an instance method with the signature <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">Inc</span> <span class="pre">()</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">interface</span><span class="w"> </span><span class="n">IIncrementable</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">void</span><span class="w"> </span><span class="nf">Inc</span><span class="w"> </span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s then say that we’re creating another interface called <code class="docutils literal notranslate"><span class="pre">IAddable</span></code> which requires that whoever implements it declares an instance method with the signature <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">Add</span> <span class="pre">(int</span> <span class="pre">y)</span></code>.
In addition to this however, the interface also inherits from the other interface <code class="docutils literal notranslate"><span class="pre">IIncrementable</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">interface</span><span class="w"> </span><span class="n">IAddable</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">IIncrementable</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">void</span><span class="w"> </span><span class="nf">Add</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<p>If we now write a class called <code class="docutils literal notranslate"><span class="pre">Number</span></code> that claims to implement <code class="docutils literal notranslate"><span class="pre">IAddable</span></code> and try to only implement the method <code class="docutils literal notranslate"><span class="pre">Add</span></code> we will get a compilation error.</p>
<div class="cell tag_raises-exception docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Number</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">IAddable</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>

<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Add</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(1,16): error CS0535: &#39;Number&#39; does not implement interface member &#39;IIncrementable.Inc()&#39;
</pre></div>
</div>
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
</div>
</div>
<p>Since <code class="docutils literal notranslate"><span class="pre">IAddable</span></code> inherits from the interface <code class="docutils literal notranslate"><span class="pre">IIncrementable</span></code>, <code class="docutils literal notranslate"><span class="pre">Number</span></code> must not only implement <code class="docutils literal notranslate"><span class="pre">Add</span></code> but also <code class="docutils literal notranslate"><span class="pre">Inc</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Number</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">IAddable</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>

<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Inc</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">x</span><span class="o">++</span><span class="p">;</span>
<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Add</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="discussion">
<h2>Discussion<a class="headerlink" href="#discussion" title="Permalink to this heading">#</a></h2>
<p>If you find the examples in this chapter awkward, you’re not alone.
I do too.</p>
<p>I have searched far and wide and the more I look, the more I get convinced that there are no good examples of inheritance where the base class is not abstract or where the whole thing is not <a class="reference internal" href="maintainability.html"><span class="doc std std-doc">better</span></a> modeled with <a class="reference internal" href="composition-over-inheritance.html"><span class="doc std std-doc">composition over inheritance</span></a>.</p>
<p>In the case of C#, you can even choose to combine interfaces and <a class="reference internal" href="../chapters/extension-methods.html#extension-methods"><span class="std std-ref">extension methods</span></a> but we’ll cover that much later.</p>
<p>However, just because all I’ve seen is white swans, doesn’t prove that there are no black swans, so if you ever come across a good example, I would really, really, really appreciate it if you would let me know.
Because I for one have given up on inheritance, just like I have given up on <span class="xref myst">object oriented programming</span>.</p>
</section>
<section id="exercises">
<h2>Exercises<a class="headerlink" href="#exercises" title="Permalink to this heading">#</a></h2>
<div class="exercise admonition" id="old/inheritance-exercise-0">

<p class="admonition-title"></p>
<section id="exercise-content">
<p>What is <em>inheritance</em>?
Use your own words, give an example, and then implement that example.</p>
</section>
</div>
<div class="exercise admonition" id="old/inheritance-exercise-1">

<p class="admonition-title"></p>
<section id="exercise-content">
<p>What is <em>overriding</em>?
Use your own words, give an example, and then implement that example.</p>
</section>
</div>
<div class="exercise admonition" id="old/inheritance-exercise-2">

<p class="admonition-title"></p>
<section id="exercise-content">
<p>What is the difference between <em>overriding</em>, <em>overloading</em>, and <em>hiding</em>?
Explain in words and then show the difference by means of an example.</p>
</section>
</div>
<div class="exercise admonition" id="old/inheritance-exercise-3">

<p class="admonition-title"></p>
<section id="exercise-content">
<p>Can the class <code class="docutils literal notranslate"><span class="pre">ReverseCipher</span></code> inherit from <code class="docutils literal notranslate"><span class="pre">CharWiseCipher</span></code>?
Why or why not?</p>
</section>
</div>
<div class="exercise admonition" id="ex:inheritance:robbers-cipher-charwisecipher">

<p class="admonition-title"></p>
<section id="exercise-content">
<p>Can the class <code class="docutils literal notranslate"><span class="pre">RobbersCipher</span></code> inherit from <code class="docutils literal notranslate"><span class="pre">CharWiseCipher</span></code>?
Why or why not?</p>
<p>Hint: Perhaps the class should be called <code class="docutils literal notranslate"><span class="pre">CharToCharSubstitutionCipher</span></code> or <code class="docutils literal notranslate"><span class="pre">CharwiseCharToCharCipher</span></code>. Why is that?</p>
</section>
</div>
<div class="exercise admonition" id="inheritance:exercises:chartostringsubstitutioncipher">

<p class="admonition-title"></p>
<section id="exercise-content">
<p>Think about your answer to <code class="xref std std-numref docutils literal notranslate"><span class="pre">ex:inheritance:robbers-cipher-charwisecipher</span></code> and use our implementation of <code class="docutils literal notranslate"><span class="pre">CharWiseCipher</span></code> (which perhaps should be called <code class="docutils literal notranslate"><span class="pre">CharToCharSubstitutionCipher</span></code>) as inspiration for the following exercise.</p>
<p>Write a class called <code class="docutils literal notranslate"><span class="pre">CharToStringSubstitutionCipher</span></code> that implements the interfaces <code class="docutils literal notranslate"><span class="pre">ICharToStringCipher</span></code> and <code class="docutils literal notranslate"><span class="pre">IStringToStringCipher</span></code>.
<code class="docutils literal notranslate"><span class="pre">RobbersCipher</span></code> should inherit from this new class in a way that makes it possible to remove the method with the signature <code class="docutils literal notranslate"><span class="pre">string</span> <span class="pre">Encode</span> <span class="pre">(string</span> <span class="pre">input)</span></code> from <code class="docutils literal notranslate"><span class="pre">RobbersCipher</span></code>.</p>
</section>
</div>
<div class="exercise admonition" id="old/inheritance-exercise-6">

<p class="admonition-title"></p>
<section id="exercise-content">
<p>Can an interface inherit from multiple interfaces?
Try it.</p>
</section>
</div>
<div class="exercise admonition" id="old/inheritance-exercise-7">

<p class="admonition-title"></p>
<section id="exercise-content">
<p>Can we introduce an interface that inherits from all our three cipher interfaces?
What would such an interface mean?
How is it useful?</p>
</section>
</div>
<div class="exercise admonition" id="ex:inheritance:triangular">

<p class="admonition-title"></p>
<section id="exercise-content">
<p>Start with the class <code class="docutils literal notranslate"><span class="pre">Sequence</span></code> that we wrote in this chapter.
Write your own subclass of the class <code class="docutils literal notranslate"><span class="pre">Sequence</span></code> that implements the <a class="reference external" href="https://en.wikipedia.org/wiki/Triangular_number">Triangular number sequence</a>.</p>
</section>
</div>
<div class="cell tag_remove-input docutils container">
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(6,7): error CS1729: &#39;Sequence&#39; does not contain a constructor that takes 1 arguments
</pre></div>
</div>
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
</div>
</div>
<div class="exercise admonition" id="ex:inheritance:fibonacci">

<p class="admonition-title"></p>
<section id="exercise-content">
<p>Start with the class <code class="docutils literal notranslate"><span class="pre">Sequence</span></code> that we wrote in this chapter.
Write your own subclass of the class <code class="docutils literal notranslate"><span class="pre">Sequence</span></code> that implements the <a class="reference external" href="https://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci sequence</a>.</p>
</section>
</div>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: ".net-csharp"
        },
        kernelOptions: {
            name: ".net-csharp",
            path: "./old"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = '.net-csharp'</script>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; All rights reserved. By using this site, you agree to our use of cookies for Google Analytics.
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Inheritance</a><ul>
<li><a class="reference internal" href="#motivation">Motivation</a></li>
<li><a class="reference internal" href="#definition">Definition</a><ul>
<li><a class="reference internal" href="#inheriting-members">Inheriting members</a></li>
<li><a class="reference internal" href="#inheriting-types">Inheriting types</a></li>
<li><a class="reference internal" href="#overriding">Overriding</a></li>
<li><a class="reference internal" href="#hiding">Hiding</a></li>
<li><a class="reference internal" href="#constructor-chaining">Constructor chaining</a></li>
<li><a class="reference internal" href="#accessing-base-members">Accessing base members</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples">Examples</a><ul>
<li><a class="reference internal" href="#sequences">Sequences</a><ul>
<li><a class="reference internal" href="#step-sequence">Step sequence</a></li>
<li><a class="reference internal" href="#evens-and-odds">Evens and odds</a></li>
<li><a class="reference internal" href="#palindromic-numbers">Palindromic numbers</a></li>
<li><a class="reference internal" href="#square-numbers">Square numbers</a></li>
</ul>
</li>
<li><a class="reference internal" href="#characterwise-ciphers">Characterwise ciphers</a></li>
<li><a class="reference internal" href="#interface-inheritance">Interface inheritance</a></li>
</ul>
</li>
<li><a class="reference internal" href="#discussion">Discussion</a></li>
<li><a class="reference internal" href="#exercises">Exercises</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script src="https://www.googletagmanager.com/gtag/js?id=G-V69WNXD095"></script>
    <script src="../_static/custom.js"></script>
    <script src="../_static/analytics.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js"></script>
    <script src="../_static/scripts/furo.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    </body>
</html>